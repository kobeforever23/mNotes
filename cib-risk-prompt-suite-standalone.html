<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CIB Risk Analytics AI Prompt Suite</title>
    <style>

:root {
  --bg: #08111c;
  --bg-elev: #0f1d2f;
  --bg-elev-2: #15263d;
  --bg-soft: #1f3149;
  --text: #e6ecf5;
  --text-muted: #9fb0c7;
  --accent: #26c6da;
  --accent-2: #f4b400;
  --success: #3ccf91;
  --warning: #ffb84d;
  --danger: #ff6b6b;
  --border: rgba(167, 194, 230, 0.2);
  --shadow: 0 16px 30px rgba(0, 0, 0, 0.28);
  --tag-quant: #00bcd4;
  --tag-analyst: #4caf50;
  --tag-leader: #ff9800;
  --tag-validator: #ef5350;
  --quick: #13a89e;
  --configurable: #2e7de9;
  --deep: #e67e22;
}

body.theme-light {
  --bg: #eaf1f7;
  --bg-elev: #ffffff;
  --bg-elev-2: #f4f8fc;
  --bg-soft: #dce6f3;
  --text: #10253f;
  --text-muted: #47607d;
  --accent: #006d8f;
  --accent-2: #a06a00;
  --success: #0f8f62;
  --warning: #996200;
  --danger: #b83e3e;
  --border: rgba(11, 46, 82, 0.18);
  --shadow: 0 12px 24px rgba(16, 37, 63, 0.15);
}

* {
  box-sizing: border-box;
}

html,
body {
  margin: 0;
  padding: 0;
  min-height: 100%;
}

body {
  font-family: 'IBM Plex Sans', sans-serif;
  background:
    radial-gradient(circle at 18% 18%, rgba(38, 198, 218, 0.12), transparent 28%),
    radial-gradient(circle at 84% 0%, rgba(244, 180, 0, 0.09), transparent 34%),
    var(--bg);
  color: var(--text);
}

h1,
h2,
h3,
h4,
p,
ul,
li,
pre {
  margin: 0;
}

.app-shell {
  min-height: 100vh;
  display: grid;
  grid-template-rows: auto 1fr;
}

.topbar {
  padding: 14px 18px;
  border-bottom: 1px solid var(--border);
  background: linear-gradient(90deg, rgba(12, 31, 52, 0.94), rgba(13, 32, 52, 0.8));
  backdrop-filter: blur(8px);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 20px;
  position: sticky;
  top: 0;
  z-index: 30;
}

body.theme-light .topbar {
  background: linear-gradient(90deg, rgba(255, 255, 255, 0.95), rgba(235, 243, 251, 0.9));
}

.brand-kicker {
  letter-spacing: 0.14em;
  text-transform: uppercase;
  font-size: 11px;
  color: var(--text-muted);
}

.brand-block h1 {
  font-size: 22px;
  font-weight: 600;
  letter-spacing: 0.01em;
}

.topbar-actions {
  display: flex;
  gap: 10px;
  align-items: center;
}

.compact-select,
.sidebar select,
.sidebar input,
input,
textarea {
  font-family: inherit;
  background: var(--bg-elev-2);
  border: 1px solid var(--border);
  color: var(--text);
  border-radius: 8px;
  padding: 8px 10px;
}

textarea {
  resize: vertical;
}

.body-grid {
  display: grid;
  grid-template-columns: 320px 1fr;
  min-height: 0;
}

.sidebar {
  border-right: 1px solid var(--border);
  padding: 14px;
  display: grid;
  grid-template-rows: auto auto auto 1fr;
  gap: 14px;
  overflow-y: auto;
  background: linear-gradient(180deg, rgba(13, 30, 50, 0.95), rgba(9, 20, 33, 0.94));
}

body.theme-light .sidebar {
  background: linear-gradient(180deg, #f8fbff, #edf4fc);
}

.nav-list {
  display: grid;
  gap: 6px;
}

.nav-item {
  text-align: left;
  font-weight: 600;
  letter-spacing: 0.01em;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid transparent;
  color: var(--text-muted);
  background: transparent;
  cursor: pointer;
}

.nav-item.is-active,
.nav-item:hover {
  background: var(--bg-soft);
  color: var(--text);
  border-color: var(--border);
}

.sidebar-panel {
  border: 1px solid var(--border);
  border-radius: 12px;
  background: rgba(17, 34, 54, 0.56);
  padding: 10px;
  display: grid;
  gap: 8px;
}

body.theme-light .sidebar-panel {
  background: rgba(255, 255, 255, 0.8);
}

.sidebar-panel h2 {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-muted);
}

.sidebar-panel label {
  display: grid;
  gap: 4px;
  font-size: 12px;
  color: var(--text-muted);
}

#searchInput {
  width: 100%;
}

.stats-panel #statsSummary {
  display: grid;
  gap: 6px;
  font-size: 13px;
  color: var(--text-muted);
}

.main-content {
  padding: 16px;
  overflow-y: auto;
}

.view-header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  margin-bottom: 14px;
  gap: 12px;
}

.view-header h2 {
  font-size: 22px;
}

.view-header p {
  margin-top: 4px;
  color: var(--text-muted);
  max-width: 80ch;
}

.metric-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 10px;
  margin-bottom: 14px;
}

.metric-card {
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 12px;
  background: var(--bg-elev);
  box-shadow: var(--shadow);
}

.metric-card .label {
  display: block;
  font-size: 12px;
  text-transform: uppercase;
  color: var(--text-muted);
  letter-spacing: 0.06em;
}

.metric-card .value {
  display: block;
  margin-top: 6px;
  font-size: 22px;
  font-weight: 700;
}

.prompt-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
  gap: 12px;
}

.prompt-card {
  border: 1px solid var(--border);
  border-radius: 14px;
  background: linear-gradient(145deg, var(--bg-elev), var(--bg-elev-2));
  padding: 12px;
  display: grid;
  gap: 10px;
  min-height: 220px;
}

.prompt-card.is-selected {
  border-color: rgba(38, 198, 218, 0.75);
  box-shadow: 0 0 0 1px rgba(38, 198, 218, 0.35), var(--shadow);
}

.prompt-card-header {
  display: flex;
  justify-content: space-between;
  gap: 8px;
}

.prompt-title {
  font-size: 16px;
  line-height: 1.25;
}

.tag-row {
  margin-top: 8px;
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.tag {
  border-radius: 999px;
  font-size: 11px;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  padding: 4px 8px;
  border: 1px solid rgba(255, 255, 255, 0.15);
  background: rgba(255, 255, 255, 0.08);
}

.tag.role-quant {
  color: var(--tag-quant);
}

.tag.role-analyst {
  color: var(--tag-analyst);
}

.tag.role-senior-leader,
.tag.role-head-of-cib-risk {
  color: var(--tag-leader);
}

.tag.role-validator,
.tag.role-compliance {
  color: var(--tag-validator);
}

.meta-row {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}

.version-pill,
.complexity-pill,
.compliance-pill {
  font-size: 11px;
  border-radius: 8px;
  padding: 4px 7px;
  border: 1px solid var(--border);
  color: var(--text-muted);
}

.complexity-pill.quick {
  color: var(--quick);
}

.complexity-pill.configurable {
  color: var(--configurable);
}

.complexity-pill.deep {
  color: var(--deep);
}

.prompt-snippet {
  color: var(--text-muted);
  font-size: 13px;
  line-height: 1.45;
  flex: 1;
}

.prompt-card-footer {
  display: flex;
  gap: 8px;
}

button {
  font-family: inherit;
  border: 1px solid transparent;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.15s ease;
}

button:focus-visible,
input:focus-visible,
select:focus-visible,
textarea:focus-visible {
  outline: 2px solid rgba(38, 198, 218, 0.65);
  outline-offset: 1px;
}

.primary-btn {
  background: linear-gradient(120deg, var(--accent), #1f8ee6);
  color: #04151f;
  font-weight: 700;
  padding: 8px 12px;
}

.primary-btn:hover {
  filter: brightness(1.08);
}

.ghost-btn,
.icon-btn {
  background: transparent;
  color: var(--text-muted);
  border-color: var(--border);
  padding: 8px 10px;
}

.ghost-btn:hover,
.icon-btn:hover {
  color: var(--text);
  background: var(--bg-soft);
}

.icon-btn {
  font-size: 12px;
}

.prompt-detail {
  display: grid;
  grid-template-columns: minmax(330px, 43%) 1fr;
  gap: 12px;
  min-height: 560px;
}

.prompt-detail.is-flash {
  animation: promptFlash 0.65s ease;
}

@keyframes promptFlash {
  0% {
    box-shadow: 0 0 0 0 rgba(38, 198, 218, 0);
  }
  40% {
    box-shadow: 0 0 0 4px rgba(38, 198, 218, 0.25);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(38, 198, 218, 0);
  }
}

.panel {
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--bg-elev);
  overflow: hidden;
}

.panel-header {
  border-bottom: 1px solid var(--border);
  padding: 10px 12px;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 8px;
}

.panel-header h3 {
  font-size: 16px;
}

.panel-header .meta {
  color: var(--text-muted);
  font-size: 12px;
  margin-top: 5px;
}

.panel-body {
  padding: 12px;
  display: grid;
  gap: 12px;
}

.variables-grid {
  display: grid;
  gap: 10px;
}

.variable-input {
  display: grid;
  gap: 5px;
  font-size: 12px;
  color: var(--text-muted);
}

.variable-input .meta-line {
  display: flex;
  justify-content: space-between;
}

.range-row {
  display: flex;
  gap: 8px;
  align-items: center;
}

.range-value {
  font-size: 12px;
  color: var(--accent);
  min-width: 70px;
  text-align: right;
}

.prompt-code {
  background: rgba(10, 21, 35, 0.9);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 12px;
  max-height: 270px;
  overflow: auto;
  font-family: 'Space Mono', monospace;
  font-size: 12px;
  line-height: 1.5;
  white-space: pre-wrap;
  color: #dbe8f8;
}

body.theme-light .prompt-code {
  background: #f9fbfe;
  color: #143251;
}

.slot-token {
  color: #ffd166;
  background: rgba(255, 209, 102, 0.12);
  border: 1px solid rgba(255, 209, 102, 0.25);
  border-radius: 4px;
  padding: 0 4px;
}

.preview-pane {
  display: grid;
  grid-template-rows: auto auto 1fr;
  gap: 12px;
}

.usage-notes {
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 10px;
  color: var(--text-muted);
  background: var(--bg-elev-2);
}

.preview-output {
  min-height: 420px;
}

.preview-output pre {
  margin: 0;
  max-height: 470px;
  overflow: auto;
  white-space: pre-wrap;
  font-family: 'Space Mono', monospace;
  font-size: 12px;
  line-height: 1.5;
  color: var(--text);
}

.feedback-block {
  border-top: 1px solid var(--border);
  padding-top: 10px;
  display: grid;
  gap: 8px;
}

.star-row {
  display: flex;
  gap: 6px;
}

.star-btn {
  border-radius: 6px;
  border: 1px solid var(--border);
  padding: 4px 7px;
  background: transparent;
  color: var(--text-muted);
}

.star-btn.active {
  color: var(--accent-2);
  border-color: rgba(244, 180, 0, 0.35);
  background: rgba(244, 180, 0, 0.1);
}

.action-row {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.overlay {
  position: fixed;
  inset: 0;
  background: rgba(5, 11, 18, 0.75);
  backdrop-filter: blur(6px);
  display: grid;
  place-items: center;
  z-index: 90;
  padding: 14px;
}

.hidden {
  display: none;
}

.modal {
  background: var(--bg-elev);
  border: 1px solid var(--border);
  border-radius: 14px;
  width: min(980px, 100%);
  max-height: 90vh;
  overflow: auto;
  box-shadow: var(--shadow);
}

.command-modal {
  width: min(920px, 100%);
}

.medium-modal {
  width: min(860px, 100%);
}

.modal-header {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal h2 {
  font-size: 16px;
}

.command-modal input,
.global-var-editor,
.command-results,
.stack-form {
  padding: 10px 12px;
}

.command-results {
  display: grid;
  gap: 7px;
}

.command-item {
  border: 1px solid var(--border);
  border-radius: 9px;
  padding: 8px;
  cursor: pointer;
  display: grid;
  gap: 4px;
  background: var(--bg-elev-2);
}

.command-item:hover,
.command-item.active {
  border-color: var(--accent);
}

.command-item small {
  color: var(--text-muted);
}

.stack-form {
  display: grid;
  gap: 10px;
}

.stack-form label {
  display: grid;
  gap: 4px;
  font-size: 12px;
  color: var(--text-muted);
}

.btn-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
}

.global-var-editor {
  display: grid;
  gap: 8px;
  max-height: 58vh;
  overflow: auto;
}

.global-row {
  display: grid;
  grid-template-columns: minmax(180px, 1fr) minmax(220px, 2fr);
  gap: 8px;
  align-items: center;
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 8px;
}

.global-row code {
  color: var(--text-muted);
}

.home-grid {
  display: grid;
  grid-template-columns: minmax(280px, 1.1fr) minmax(340px, 1.2fr) minmax(300px, 1fr);
  gap: 12px;
}

.home-panel {
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--bg-elev);
  padding: 12px;
  display: grid;
  gap: 10px;
}

.home-panel h3 {
  font-size: 14px;
}

.simple-list {
  display: grid;
  gap: 7px;
}

.simple-list button,
.simple-list .item {
  text-align: left;
  border: 1px solid var(--border);
  border-radius: 9px;
  background: var(--bg-elev-2);
  color: var(--text);
  padding: 8px;
}

.builder-grid {
  display: grid;
  grid-template-columns: minmax(320px, 1fr) minmax(360px, 1fr);
  gap: 12px;
}

.builder-panel {
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--bg-elev);
  padding: 12px;
  display: grid;
  gap: 10px;
}

.builder-panel h3 {
  font-size: 14px;
}

.draggable-list {
  display: grid;
  gap: 8px;
}

.drag-item {
  border: 1px solid var(--border);
  border-radius: 9px;
  padding: 8px;
  background: var(--bg-elev-2);
  cursor: grab;
}

.drag-item.dragging {
  opacity: 0.6;
}

.workflow-grid {
  display: grid;
  grid-template-columns: minmax(270px, 0.9fr) minmax(360px, 1.2fr);
  gap: 12px;
}

.workflow-step {
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px;
  background: var(--bg-elev-2);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}

.badge {
  border: 1px solid var(--border);
  padding: 2px 6px;
  border-radius: 999px;
  font-size: 11px;
  color: var(--text-muted);
}

.empty-state {
  border: 1px dashed var(--border);
  border-radius: 12px;
  padding: 20px;
  color: var(--text-muted);
  text-align: center;
}

.inline-strong {
  color: var(--text);
  font-weight: 600;
}

.kbd {
  border: 1px solid var(--border);
  border-radius: 5px;
  font-size: 11px;
  padding: 2px 6px;
  background: var(--bg-elev-2);
  color: var(--text-muted);
}

@media (max-width: 1260px) {
  .body-grid {
    grid-template-columns: 280px 1fr;
  }

  .home-grid {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 980px) {
  .body-grid {
    grid-template-columns: 1fr;
  }

  .sidebar {
    position: sticky;
    top: 68px;
    z-index: 20;
    max-height: 52vh;
    border-right: 0;
    border-bottom: 1px solid var(--border);
  }

  .prompt-detail,
  .builder-grid,
  .workflow-grid {
    grid-template-columns: 1fr;
  }
}
</style>
  </head>
  <body>
    <div class="app-shell">
      <header class="topbar">
        <div class="brand-block">
          <div class="brand-kicker">CIB RISK ANALYTICS</div>
          <h1>AI Prompt Suite</h1>
        </div>
        <div class="topbar-actions">
          <button class="ghost-btn" id="openCommandPalette" title="Ctrl+K">Command Palette</button>
          <select id="roleSelector" class="compact-select" aria-label="Select role">
            <option value="All">All Roles</option>
            <option value="Quant">Quant</option>
            <option value="Analyst">Analyst</option>
            <option value="Senior Leader">Senior Leader</option>
            <option value="Validator">Validator</option>
            <option value="Head of CIB Risk">Head of CIB Risk</option>
            <option value="Data Engineer">Data Engineer</option>
            <option value="Quant Developer">Quant Developer</option>
            <option value="Compliance">Compliance</option>
          </select>
          <button id="themeToggle" class="ghost-btn" aria-label="Toggle theme">Light Mode</button>
          <button id="openGlobalVars" class="ghost-btn">Global Vars</button>
        </div>
      </header>

      <div class="body-grid">
        <aside class="sidebar">
          <nav id="primaryNav" class="nav-list" aria-label="Primary">
            <button data-view="home" class="nav-item is-active">Home</button>
            <button data-view="role" class="nav-item">By Role</button>
            <button data-view="function" class="nav-item">By Func</button>
            <button data-view="workflow" class="nav-item">By Workflow</button>
            <button data-view="builder" class="nav-item">Builder</button>
            <button data-view="library" class="nav-item">My Lib</button>
          </nav>

          <section class="sidebar-panel">
            <h2>Search</h2>
            <input id="searchInput" type="search" placeholder="Search prompts, domains, tags" />
          </section>

          <section class="sidebar-panel">
            <h2>Filters</h2>
            <label>
              Domain
              <select id="domainFilter"></select>
            </label>
            <label>
              Complexity
              <select id="complexityFilter"></select>
            </label>
            <label>
              Regulatory
              <select id="regulatoryFilter"></select>
            </label>
            <label>
              Output
              <select id="outputFilter"></select>
            </label>
          </section>

          <section class="sidebar-panel stats-panel">
            <h2>Library Stats</h2>
            <div id="statsSummary"></div>
          </section>
        </aside>

        <main id="mainContent" class="main-content" tabindex="-1"></main>
      </div>
    </div>

    <div id="commandPalette" class="overlay hidden" role="dialog" aria-modal="true" aria-label="Command palette">
      <div class="modal command-modal">
        <div class="modal-header">
          <h2>Command Palette</h2>
          <button class="icon-btn" data-close="commandPalette">Close</button>
        </div>
        <input id="commandInput" type="search" placeholder="Jump to prompt, section, or action" />
        <div id="commandResults" class="command-results"></div>
      </div>
    </div>

    <div id="forkModal" class="overlay hidden" role="dialog" aria-modal="true" aria-label="Fork prompt">
      <div class="modal medium-modal">
        <div class="modal-header">
          <h2>Fork and Edit Prompt</h2>
          <button class="icon-btn" data-close="forkModal">Close</button>
        </div>
        <form id="forkForm" class="stack-form">
          <label>Title<input id="forkTitle" required /></label>
          <label>Roles (comma separated)<input id="forkRoles" /></label>
          <label>Domains (comma separated)<input id="forkDomains" /></label>
          <label>Complexity
            <select id="forkComplexity">
              <option>Quick Use</option>
              <option selected>Configurable</option>
              <option>Deep Build</option>
            </select>
          </label>
          <label>Prompt<textarea id="forkPrompt" rows="14" required></textarea></label>
          <label>Usage Notes<textarea id="forkUsageNotes" rows="4"></textarea></label>
          <label>Compliance Tag
            <select id="forkCompliance">
              <option>Internal Use</option>
              <option>Regulatory Submission Ready</option>
            </select>
          </label>
          <div class="btn-row">
            <button type="submit" class="primary-btn">Save to My Library</button>
            <button type="button" id="submitForReview" class="ghost-btn">Save and Submit for Review</button>
          </div>
        </form>
      </div>
    </div>

    <div id="globalVarsModal" class="overlay hidden" role="dialog" aria-modal="true" aria-label="Global variables">
      <div class="modal medium-modal">
        <div class="modal-header">
          <h2>Global Variables and Presets</h2>
          <button class="icon-btn" data-close="globalVarsModal">Close</button>
        </div>
        <div id="globalVarEditor" class="global-var-editor"></div>
        <div class="btn-row">
          <input id="presetNameInput" placeholder="Preset name" />
          <button id="savePresetBtn" class="primary-btn">Save Preset</button>
          <select id="presetSelect"></select>
          <button id="loadPresetBtn" class="ghost-btn">Load Preset</button>
        </div>
      </div>
    </div>

    <template id="promptCardTemplate">
      <article class="prompt-card">
        <header class="prompt-card-header">
          <div class="prompt-title-block">
            <h3 class="prompt-title"></h3>
            <div class="tag-row"></div>
          </div>
          <div class="prompt-actions-inline">
            <button class="icon-btn fav-btn" title="Favorite">Favorite</button>
          </div>
        </header>
        <div class="meta-row">
          <span class="version-pill"></span>
          <span class="complexity-pill"></span>
          <span class="compliance-pill"></span>
        </div>
        <p class="prompt-snippet"></p>
        <div class="prompt-card-footer">
          <button class="primary-btn open-btn">Open</button>
          <button class="ghost-btn fork-btn">Fork</button>
        </div>
      </article>
    </template>

    <script>
(() => {
const defaultUsageNotes =
  'Use a frontier reasoning model for strongest quantitative quality. Validate formulas and assumptions against internal policy before production use.';

const mk = (config) => ({
  version: '1.0.0',
  complexity: 'Configurable',
  complianceTag: 'Internal Use',
  usageNotes: defaultUsageNotes,
  variables: [],
  related: [],
  ...config,
});

const marketPrompts = [
  mk({
    id: 'A.1.1',
    title: 'Comprehensive VaR Methodology Comparison',
    category: 'Market Risk',
    section: 'A.1 VaR Analysis & Backtesting',
    roles: ['Quant', 'Analyst', 'Validator'],
    domains: ['Market Risk', 'VaR', 'FRTB'],
    riskType: 'Market Risk',
    complexity: 'Deep Build',
    regulatory: ['Basel III', 'Basel IV', 'FRTB'],
    outputTypes: ['Structured Report', 'LaTeX', 'Decision Tree'],
    complianceTag: 'Regulatory Submission Ready',
    variables: [
      {
        name: 'number_of_desks',
        label: 'Number of desks',
        type: 'select',
        options: ['5', '10', '15', '19', '25+'],
        default: '19',
      },
      {
        name: 'number_of_risk_drivers',
        label: 'Number of risk drivers',
        type: 'slider',
        min: 50000,
        max: 500000,
        step: 5000,
        default: 250000,
      },
      {
        name: 'asset_class',
        label: 'Asset class',
        type: 'multiselect',
        options: ['Rates', 'FX', 'Equities', 'Credit', 'Commodities', 'Cross-Asset'],
        default: ['Cross-Asset'],
      },
      {
        name: 'lookback_window',
        label: 'Lookback window (days)',
        type: 'slider',
        min: 250,
        max: 1500,
        step: 25,
        default: 750,
      },
      {
        name: 'distribution_assumption',
        label: 'Distribution assumption',
        type: 'select',
        options: ['Normal', 'Student-t (df=6)', 'Cornish-Fisher', 'Generalized Hyperbolic'],
        default: 'Student-t (df=6)',
      },
      {
        name: 'copula_type',
        label: 'Copula',
        type: 'select',
        options: ['Gaussian', 'Student-t', 'Clayton', 'Gumbel', 'Frank', 'Vine'],
        default: 'Student-t',
      },
      {
        name: 'confidence_level',
        label: 'Confidence level',
        type: 'select',
        options: ['95%', '97.5%', '99%', '99.5%', '99.9%'],
        default: '99%',
      },
      {
        name: 'number_of_simulations',
        label: 'Number of simulations',
        type: 'select',
        options: ['10K', '50K', '100K', '500K', '1M'],
        default: '100K',
      },
    ],
    related: ['A.1.2', 'A.1.3', 'A.1.4'],
    prompt: `You are a senior quantitative analyst at a G-SIB's CIB Market Risk division overseeing
{{number_of_desks}} trading desks with {{number_of_risk_drivers}} risk drivers.

Produce a rigorous comparative analysis of the following VaR methodologies for our
{{asset_class}} portfolio:

1. Historical Simulation (HS-VaR) with {{lookback_window}} day lookback
2. Filtered Historical Simulation (FHS) using GARCH(1,1) volatility scaling
3. Parametric VaR assuming {{distribution_assumption}} distribution
4. Monte Carlo VaR with {{number_of_simulations}} simulations using {{copula_type}} copula

For each methodology, provide:
- Mathematical formulation with all assumptions explicitly stated
- Treatment of fat tails and tail dependence
- Sensitivity to lookback window and confidence level ({{confidence_level}})
- Computational complexity and scalability considerations for {{number_of_risk_drivers}} risk factors
- Known failure modes and when each methodology systematically underestimates risk
- Regulatory acceptability under Basel III/IV FRTB framework
- Specific advantages/disadvantages for {{asset_class}} portfolios

Then produce a recommendation matrix mapping portfolio characteristics to optimal
VaR methodology, with particular attention to portfolios with significant optionality,
illiquid positions, and concentrated exposures.

Format: Structured report with mathematical notation (LaTeX where helpful), comparison
tables, and a decision tree for methodology selection.`,
  }),
  mk({
    id: 'A.1.2',
    title: 'VaR Backtesting Diagnostic Suite',
    category: 'Market Risk',
    section: 'A.1 VaR Analysis & Backtesting',
    roles: ['Validator', 'Quant', 'Analyst'],
    domains: ['Market Risk', 'VaR Backtesting', 'Model Validation'],
    riskType: 'Market Risk',
    complexity: 'Deep Build',
    regulatory: ['SR 11-7', 'Basel III'],
    outputTypes: ['Validation Report', 'Statistical Test Table'],
    complianceTag: 'Regulatory Submission Ready',
    variables: [
      { name: 'model_id', type: 'text', default: 'MR-VAR-042' },
      { name: 'var_methodology', type: 'select', options: ['HS', 'FHS', 'Parametric', 'Monte Carlo'], default: 'FHS' },
      { name: 'desk_name', type: 'text', default: 'Global Macro Rates' },
      { name: 'start_date', type: 'date', default: '2024-01-01' },
      { name: 'end_date', type: 'date', default: '2025-12-31' },
      { name: 'num_trading_days', type: 'number', default: 500 },
      { name: 'confidence_level', type: 'select', options: ['95%', '97.5%', '99%'], default: '99%' },
      { name: 'num_exceptions', type: 'number', default: 8 },
      { name: 'expected_exceptions', type: 'number', default: 5 },
    ],
    related: ['A.1.1', 'A.1.3', 'C.3'],
    prompt: `You are the lead model validator reviewing backtesting results for model {{model_id}}
({{var_methodology}} VaR) covering the {{desk_name}} trading desk.

Given the following backtesting data:
- Observation period: {{start_date}} to {{end_date}} ({{num_trading_days}} trading days)
- Confidence level: {{confidence_level}}
- Number of VaR exceptions: {{num_exceptions}}
- Expected exceptions: {{expected_exceptions}}

Perform and interpret the following backtesting suite:

Unconditional Coverage Tests:
1. Kupiec POF (Proportion of Failures) test - compute LR statistic, p-value, pass/fail
2. Binomial test - exact probability of observing >= {{num_exceptions}} exceptions
3. Basel traffic light classification (Green/Yellow/Red zone with plus factor)

Conditional Coverage and Independence:
4. Christoffersen Interval Forecast test - test for exception clustering
5. Christoffersen Joint test (coverage + independence simultaneously)
6. Runs test for serial independence of exceptions
7. Duration-based tests (Christoffersen and Pelletier) - analyze time between exceptions

Distribution and Calibration:
8. Berkowitz transform test - are VaR quantiles correctly calibrated across the distribution?
9. QQ plot interpretation guidance for PIT (Probability Integral Transform) residuals
10. Conditional calibration - does the model perform equally well in high-vol vs. low-vol regimes?

Diagnostic Analysis:
11. Exception clustering analysis - are exceptions concentrated in specific periods? Map to market events.
12. Exception magnitude analysis - when VaR is breached, by how much? (Expected Shortfall comparison)
13. Asymmetry analysis - are exceptions concentrated on long or short side?
14. Risk factor attribution - which risk factors drive the largest exceptions?

For each test, provide: the statistical test formulation, the test statistic formula,
critical values at 1% and 5% significance, interpretation of the result, and specific
remediation recommendations if the test fails.

Conclude with an overall assessment using a structured verdict:
- Model adequacy determination (Adequate / Adequate with conditions / Inadequate)
- Specific model weaknesses identified
- Prioritized remediation recommendations
- Compensating controls to consider if model remains in production

Format: Structured validation report suitable for inclusion in a formal Model Validation
Document per SR 11-7 standards.`,
  }),
  mk({
    id: 'A.1.3',
    title: 'VaR Exception Root Cause Analyzer',
    category: 'Market Risk',
    section: 'A.1 VaR Analysis & Backtesting',
    roles: ['Analyst', 'Quant', 'Validator'],
    domains: ['Market Risk', 'P&L Attribution', 'Backtesting'],
    riskType: 'Market Risk',
    complexity: 'Deep Build',
    outputTypes: ['Investigation Report', 'Action Register'],
    regulatory: ['SR 11-7'],
    variables: [
      { name: 'model_id', type: 'text', default: 'MR-VAR-042' },
      { name: 'var_methodology', type: 'select', options: ['HS', 'FHS', 'Parametric', 'Monte Carlo'], default: 'FHS' },
      { name: 'desk_name', type: 'text', default: 'Cross-Asset Macro' },
      { name: 'exception_date', type: 'date', default: '2026-01-21' },
      { name: 'confidence_level', type: 'select', options: ['95%', '99%'], default: '99%' },
      { name: 'var_amount', type: 'text', default: '54,000,000' },
      { name: 'actual_pnl', type: 'text', default: '-132,000,000' },
      { name: 'currency', type: 'select', options: ['USD', 'EUR', 'GBP', 'JPY'], default: 'USD' },
      { name: 'exception_magnitude', type: 'number', default: 2.44 },
    ],
    related: ['A.1.2', 'A.2.3'],
    prompt: `You are a senior market risk analyst investigating a VaR exception event.

Context:
- Model: {{model_id}} ({{var_methodology}})
- Desk: {{desk_name}}
- Exception Date: {{exception_date}}
- VaR ({{confidence_level}}): {{var_amount}} {{currency}}
- Actual P&L: {{actual_pnl}} {{currency}}
- Exception Magnitude: {{exception_magnitude}}x VaR

Produce a comprehensive root cause analysis framework:

1. Market Event Decomposition: What market moves occurred on {{exception_date}}?
   Structure the analysis by risk factor category:
   - Interest rates (level, slope, curvature by currency)
   - FX spot and vol
   - Equity indices and single names
   - Credit spreads (IG, HY, sovereign)
   - Commodity prices
   - Cross-asset correlations (did correlations spike?)

2. P&L Attribution Waterfall: Decompose the {{actual_pnl}} into:
   - Delta P&L (first-order sensitivities)
   - Gamma/Convexity P&L (second-order)
   - Vega P&L (volatility surface moves)
   - Theta/Carry
   - Cross-gamma and correlation P&L
   - Residual/Unexplained
   Map each component to the risk factors that drove it.

3. Model Failure Mode Analysis: Determine which of these contributed:
   - Fat tail underestimation
   - Correlation breakdown
   - Volatility regime shift
   - Liquidity gap
   - Concentration risk
   - Missing risk factors
   - Stale/incorrect position data

4. Historical Precedent Scan: Identify the 5 most similar historical episodes
   and whether the model also failed during those periods.

5. Remediation Assessment: For each identified cause, recommend:
   - Immediate compensating control
   - Medium-term model enhancement
   - Whether this exception should trigger a formal model review

Format: Investigation report with executive summary, detailed analysis sections,
and action items with owners and deadlines.`,
  }),
  mk({
    id: 'A.1.4',
    title: 'Stressed VaR Calibration Framework',
    category: 'Market Risk',
    section: 'A.1 VaR Analysis & Backtesting',
    roles: ['Quant', 'Validator'],
    domains: ['Market Risk', 'SVaR', 'FRTB'],
    riskType: 'Market Risk',
    complexity: 'Deep Build',
    regulatory: ['Basel 2.5', 'FRTB', 'SR 11-7'],
    complianceTag: 'Regulatory Submission Ready',
    variables: [
      { name: 'asset_class', type: 'multiselect', options: ['Rates', 'FX', 'Equities', 'Credit', 'Commodities'], default: ['Rates', 'Credit'] },
      { name: 'desk_coverage', type: 'number', default: 19 },
      { name: 'number_of_risk_drivers', type: 'slider', min: 50000, max: 500000, step: 5000, default: 200000 },
      {
        name: 'candidate_stress_periods',
        type: 'textarea',
        default:
          '2007-2008 GFC, 2010-2011 European Sovereign Crisis, 2013 Taper Tantrum, 2015 CNY Devaluation, 2018 Q4 Vol Spike, 2020 COVID Crash, 2022 Rate Shock, 2023 Banking Crisis',
      },
    ],
    related: ['A.1.1', 'C.2'],
    prompt: `You are a quantitative risk modeler tasked with calibrating the Stressed VaR (SVaR)
model for {{asset_class}} across {{desk_coverage}} desks.

Under Basel 2.5 / FRTB requirements, SVaR must be calibrated to a continuous
12-month period of significant financial stress relevant to the portfolio.

Build a complete SVaR calibration framework:

1. Stress Period Identification Methodology:
   - Define quantitative criteria for identifying candidate stress periods
   - For {{asset_class}}, evaluate these candidate periods:
     {{candidate_stress_periods}}
   - Develop a scoring methodology that balances portfolio relevance, severity,
     risk factor coverage, and regulatory acceptability
   - Address the circularity problem: stress period depends on portfolio composition,
     but portfolio changes over time

2. Stress Period Validation:
   - Statistical tests confirming the selected period produces materially higher VaR
   - Minimum ratio of SVaR/VaR that demonstrates adequate stress calibration
   - Sensitivity analysis for stress window shifts by +/-1/3/6 months

3. Implementation Considerations:
   - Handling risk factors that did not exist during the stress period
   - Proxy methodology for missing data
   - Structural market changes (e.g., negative rates)
   - Antithetic/volatility-scaled approaches vs direct historical approaches
   - Computational optimization for {{number_of_risk_drivers}} risk drivers

4. Ongoing Monitoring Framework:
   - Triggers for stress period recalibration
   - Quarterly review checklist
   - Documentation requirements per SR 11-7 and FRTB

Candidate stress periods to evaluate:
{{candidate_stress_periods}}

Format: Technical specification document with mathematical formulations,
decision criteria tables, and implementation pseudocode.`,
  }),
  mk({
    id: 'A.2.1',
    title: 'CCAR/DFAST Scenario Translation Engine',
    category: 'Market Risk',
    section: 'A.2 Stress Testing & Scenario Analysis',
    roles: ['Quant', 'Analyst', 'Senior Leader'],
    domains: ['Stress Testing', 'CCAR', 'Scenario Translation'],
    riskType: 'Market Risk',
    complexity: 'Deep Build',
    regulatory: ['CCAR', 'DFAST'],
    complianceTag: 'Regulatory Submission Ready',
    outputTypes: ['Technical Document', 'Shock Tables'],
    variables: [
      { name: 'number_of_desks', type: 'number', default: 19 },
      { name: 'number_of_risk_drivers', type: 'slider', min: 50000, max: 500000, step: 5000, default: 220000 },
      {
        name: 'macro_scenario_inputs',
        type: 'textarea',
        default:
          'Real GDP: -4.2%, Unemployment: 9.4%, S&P 500: -45%, 10Y Treasury: 1.6%, BBB Spread: +350bps, VIX: 54, House Price Index: -22%, CRE Price Index: -28%',
      },
      {
        name: 'additional_currencies',
        type: 'multiselect',
        options: ['AUD', 'CAD', 'NOK', 'SEK', 'NZD', 'SGD', 'HKD', 'CNH', 'MXN', 'BRL', 'ZAR', 'KRW'],
        default: ['CAD', 'AUD', 'CNH'],
      },
    ],
    related: ['A.2.3', 'C.1', 'G.5'],
    prompt: `You are the lead quantitative analyst responsible for translating Fed-prescribed
macroeconomic scenarios into granular market risk factor shocks for CCAR/DFAST
stress testing across {{number_of_desks}} CIB trading desks with
{{number_of_risk_drivers}} risk drivers.

The Fed's Severely Adverse scenario specifies the following macro variables:
{{macro_scenario_inputs}}

Build the complete translation framework:

1. Macro-to-Market-Factor Mapping Architecture with four layers:
   Level 1 macro variables, Level 2 broad market categories, Level 3 granular risk factors,
   Level 4 desk-level risk drivers. For each transition specify model form, assumptions,
   confidence bounds, and expert overlays.

2. Risk Factor Shock Specifications:
   - Interest rates across major currencies and {{additional_currencies}}
   - Credit spreads by rating, sector, sovereign, and basis
   - Equities (indices, dispersion, vol surfaces)
   - FX spot and vol surfaces
   - Commodities and curve shape dynamics

3. Consistency Checks:
   - Cross-asset arbitrage consistency
   - Historical plausibility
   - Severity benchmarking vs historical stress episodes
   - Narrative coherence

4. Sensitivity and Uncertainty Analysis:
   - Outcome ranges for key translation assumptions
   - Top assumptions driving stressed P&L
   - Model improvement priorities

5. Documentation Package:
   - Methodology for Fed horizontal review
   - Assumption inventory with justification
   - Prior-year comparison
   - Likely Fed challenge questions with responses

Format: Comprehensive technical document with data tables for shocked values,
methodology descriptions, and an executive summary suitable for CRO presentation.`,
  }),
  mk({
    id: 'A.2.2',
    title: 'Reverse Stress Test Designer',
    category: 'Market Risk',
    section: 'A.2 Stress Testing & Scenario Analysis',
    roles: ['Senior Leader', 'Analyst', 'Quant'],
    domains: ['Reverse Stress Testing', 'Scenario Design'],
    riskType: 'Market Risk',
    complexity: 'Deep Build',
    outputTypes: ['Board Deck Narrative', 'Scenario Map'],
    variables: [
      { name: 'business_line', type: 'text', default: 'Global Rates and Credit Macro' },
      { name: 'total_notional', type: 'text', default: 'USD 1.2T' },
      { name: 'primary_exposures', type: 'textarea', default: 'Long IG spread carry, short payer skew, long EM local rates, short USDJPY gamma' },
      { name: 'key_hedges', type: 'textarea', default: 'CDX IG protection, receiver swaptions, equity downside puts, dynamic FX delta hedges' },
      { name: 'current_var', type: 'text', default: 'USD 65mm' },
      { name: 'loss_threshold', type: 'text', default: 'USD 500mm' },
    ],
    related: ['A.2.1', 'L.1', 'E.3'],
    prompt: `You are a senior risk strategist designing reverse stress tests for the
{{business_line}} within CIB. The current portfolio has:
- Notional: {{total_notional}}
- Primary exposures: {{primary_exposures}}
- Key hedges: {{key_hedges}}
- Current VaR (99%, 1-day): {{current_var}}

Reverse stress testing asks: "What scenarios would cause losses exceeding
{{loss_threshold}}, threatening the viability of this business line?"

Design a comprehensive reverse stress testing framework:

1. Systematic Scenario Identification:
   Work backward from a {{loss_threshold}} loss to identify single-factor and multi-factor
   shocks, model-weakness scenarios, wrong-way risk combinations, and operational overlays.

2. Plausibility Assessment Framework:
   Score each scenario using historical frequency, current environment, and microstructure.
   Map each scenario to plausible real-world triggers and unfolding horizons.

3. Portfolio Vulnerability Map:
   Identify desk-level contributors, fragile correlations, hedge failure points,
   and second-order effects (margin calls, forced liquidation).

4. Early Warning Indicators:
   Define 3-5 observable indicators per scenario, threshold levels,
   monitoring cadence, and escalation protocols.

5. Management Action Framework:
   Specify pre-positioned hedges, trigger levels for contingency actions,
   de-risk execution time/cost, and residual risk.

Format: Board-ready document with scenario narratives, quantitative specifications,
heat maps, and action plans.`,
  }),
  mk({
    id: 'A.2.3',
    title: 'Scenario P&L Impact Calculator Prompt',
    category: 'Market Risk',
    section: 'A.2 Stress Testing & Scenario Analysis',
    roles: ['Analyst', 'Quant'],
    domains: ['P&L Attribution', 'Stress Testing', 'Liquidity'],
    riskType: 'Market Risk',
    complexity: 'Deep Build',
    outputTypes: ['Computation Table', 'Waterfall'],
    variables: [
      { name: 'scenario_type', type: 'select', options: ['CCAR', 'Idiosyncratic', 'Historical Replay', 'Hypothetical'], default: 'Historical Replay' },
      { name: 'desk_name', type: 'text', default: 'Cross-Asset Exotics' },
      { name: 'risk_factor_shocks', type: 'textarea', default: 'USD curve +120bps bear flattening, IG spreads +180bps, SPX -12%, VIX +18pts, USDJPY -4%' },
      { name: 'portfolio_sensitivities', type: 'textarea', default: 'DV01, CS01, Vega buckets, equity delta/gamma, FX delta, funding and margin sensitivities' },
    ],
    related: ['A.1.3', 'L.1', 'L.2'],
    prompt: `You are a market risk analyst computing the P&L impact of a {{scenario_type}} scenario
on the {{desk_name}} portfolio.

The scenario specifies the following risk factor shocks:
{{risk_factor_shocks}}

The portfolio's current risk sensitivities are:
{{portfolio_sensitivities}}

Compute and explain:

1. First-Order (Linear) P&L Impact:
   - Delta/DV01, CS01, FX delta, Vega, and total first-order P&L

2. Second-Order (Convexity) Adjustments:
   - Gamma/convexity, cross-gamma, vanna, volga, and their relevance for this shock size

3. Liquidity-Adjusted Impact:
   - Positions not liquidatable at mid, bid-ask widening by asset class,
     liquidation horizons, and liquidity-adjusted P&L

4. Funding and Margin Impact:
   - Margin calls, funding spread impacts, collateral transformation costs,
     and total liquidity demand

5. Aggregation and Diversification Analysis:
   - Gross vs net P&L, hedge effectiveness, diversification benefit,
     and worst-case correlation shift to +/-1

Present results as a waterfall:
Starting portfolio value -> first-order impacts -> second-order adjustments -> liquidity adjustment -> funding impact -> final stressed value.

Format: Quantitative report with waterfall data, detailed computation tables,
and narrative interpretation of results.`,
  }),
  mk({
    id: 'A.3.1',
    title: 'Risk Driver Hierarchy and Shock Propagation Designer',
    category: 'Market Risk',
    section: 'A.3 Risk Factor & Sensitivity Analysis',
    roles: ['Quant', 'Quant Developer'],
    domains: ['Risk Architecture', 'Stress Testing', 'Factor Models'],
    riskType: 'Market Risk',
    complexity: 'Deep Build',
    outputTypes: ['Technical Architecture', 'Pseudocode'],
    variables: [
      { name: 'number_of_risk_drivers', type: 'slider', min: 50000, max: 500000, step: 5000, default: 260000 },
      { name: 'number_of_desks', type: 'number', default: 19 },
    ],
    related: ['A.2.1', 'D.7', 'F.2'],
    prompt: `You are the lead quantitative architect designing a hierarchical risk driver framework
for a CIB risk system covering {{number_of_risk_drivers}} risk drivers across
{{number_of_desks}} trading desks.

The challenge: When running stress scenarios, we cannot independently shock
{{number_of_risk_drivers}} risk drivers. We need a structured hierarchy that enables
"shock at the top, propagate downward" while maintaining economic coherence.

Design the complete hierarchy:

1. Tier 1 - Macro Drivers (10-20): define each driver, economic interpretation, and data source.
2. Tier 2 - Market Segment Drivers (100-500): specify mapping from Tier 1,
   residual structure, and examples.
3. Tier 3 - Granular Risk Factors (5,000-50,000): mapping, basis risk treatment,
   and illiquid proxy methodology.
4. Tier 4 - Position-Level Sensitivities ({{number_of_risk_drivers}}):
   Greeks mapping, cash-flow mapping, and exotic treatment.
5. Propagation Mechanics: equations for tier-to-tier transfer, nonlinearity,
   correlation structures, no-arbitrage controls, and computational optimization.
6. Validation Framework: historical replay, plausibility tests, assumption sensitivities.

Format: Technical architecture document with mathematical specifications,
entity-relationship diagrams, and implementation pseudocode.`,
  }),
  mk({
    id: 'A.3.2',
    title: 'Greeks and Sensitivity Deep Dive for Exotic Book',
    category: 'Market Risk',
    section: 'A.3 Risk Factor & Sensitivity Analysis',
    roles: ['Quant', 'Analyst'],
    domains: ['Exotics', 'Greeks', 'Hedging'],
    riskType: 'Market Risk',
    complexity: 'Deep Build',
    outputTypes: ['Risk Report', 'Sensitivity Tables'],
    variables: [
      { name: 'exotic_product_type', type: 'select', options: ['Autocallables', 'Callable Range Accruals', 'Barrier Baskets', 'Quanto Cliquets'], default: 'Barrier Baskets' },
      { name: 'desk_name', type: 'text', default: 'Cross-Asset Exotics' },
      { name: 'book_notional', type: 'text', default: 'USD 18bn' },
      { name: 'num_trades', type: 'number', default: 1274 },
      { name: 'pricing_model', type: 'select', options: ['Local Stochastic Vol', 'Heston', 'SABR', 'Hybrid MC'], default: 'Local Stochastic Vol' },
    ],
    related: ['D.2', 'F.2'],
    prompt: `You are a senior quant responsible for risk analysis of the {{exotic_product_type}}
book on the {{desk_name}} desk.

The book currently has:
- Notional: {{book_notional}}
- Number of trades: {{num_trades}}
- Primary model: {{pricing_model}}

Produce a comprehensive sensitivity analysis framework:

1. Standard Greeks with nuance for {{exotic_product_type}}:
   delta, gamma, vega, theta, rho, and correlation sensitivity including discontinuities and path dependence.

2. Higher-order and cross-greeks:
   vanna, volga, speed, charm, color with interpretation and hedging implications.

3. Model-specific sensitivities:
   sensitivity to {{pricing_model}} calibration parameters,
   discretization, boundary behavior, and alternative model comparisons.

4. Hedging strategy design:
   instrument selection, dynamic hedging frequency, static vs dynamic trade-offs,
   slippage estimates, and P&L explain linkage.

5. Risk limits framework:
   Greek limits, suggested levels, monitoring frequency, and breach escalation.

Format: Quantitative risk report with mathematical derivations, sensitivity tables,
3D surface plot specifications, and hedging recommendations.`,
  }),
  mk({
    id: 'A.4.1',
    title: 'Intraday VaR Escalation Playbook Prompt',
    category: 'Market Risk',
    section: 'A.4 Trading Risk Control',
    roles: ['Analyst', 'Senior Leader'],
    domains: ['Intraday Risk', 'Limit Management'],
    riskType: 'Market Risk',
    complexity: 'Configurable',
    outputTypes: ['Playbook', 'Escalation Matrix'],
    variables: [
      { name: 'intraday_var_limit', type: 'text', default: 'USD 85mm' },
      { name: 'current_intraday_var', type: 'text', default: 'USD 103mm' },
      { name: 'desk_cluster', type: 'text', default: 'Rates + Credit Macro' },
      { name: 'market_context', type: 'textarea', default: 'US CPI surprise, front-end rates repricing, IG spread widening, equity vol up 6 vols' },
    ],
    prompt: `You are the intraday risk lead for {{desk_cluster}}.

Current state:
- Intraday VaR limit: {{intraday_var_limit}}
- Current intraday VaR: {{current_intraday_var}}
- Market context: {{market_context}}

Produce an escalation playbook that includes:
1. Immediate triage: data integrity checks, stale sensitivities checks, hedge effectiveness check, and temporary risk freeze criteria.
2. Decomposition: identify top positions/risk factors responsible for breach using marginal and incremental VaR.
3. Action ladder: 15-minute, 60-minute, and end-of-day actions with explicit owners.
4. Governance: communication protocol to desk head, CRO delegate, and control functions.
5. Decision framework: hold-risk, hedge-risk, or unwind-risk with objective thresholds.
6. Post-event review: required evidence pack and permanent control recommendations.

Format: Operator-grade escalation runbook with thresholds, RACI table, and message templates.`,
  }),
  mk({
    id: 'A.4.2',
    title: 'Stress-of-Stress Correlation Break Designer',
    category: 'Market Risk',
    section: 'A.4 Trading Risk Control',
    roles: ['Quant', 'Validator'],
    domains: ['Correlation Stress', 'Tail Risk'],
    riskType: 'Market Risk',
    complexity: 'Deep Build',
    outputTypes: ['Scenario Pack', 'Method Note'],
    variables: [
      { name: 'portfolio_scope', type: 'text', default: 'Global Macro + Equity Derivatives' },
      { name: 'base_stress', type: 'text', default: '2020 COVID Week 1 replay' },
      { name: 'correlation_assumptions', type: 'textarea', default: 'Current stressed matrix uses 75th percentile crisis correlations with sector floor at 0.55' },
    ],
    prompt: `You are designing a second-layer stress overlay for {{portfolio_scope}}.
Base stress scenario: {{base_stress}}.
Current correlation assumptions: {{correlation_assumptions}}.

Design a stress-of-stress methodology that:
1. Defines correlation break mechanisms (convergence-to-one, sign flips, regime bifurcation).
2. Applies positive-definite preserving transformations and documents why they are stable.
3. Produces five calibrated overlays with severity labels and plausibility scoring.
4. Quantifies incremental loss vs base stress and identifies diversification illusion risk.
5. Specifies governance triggers for activating each overlay in live risk monitoring.

Format: Quantitative design note with transformation equations, calibration rules, and output tables.`,
  }),
  mk({
    id: 'A.4.3',
    title: 'Basis Risk Heatmap Generator Prompt',
    category: 'Market Risk',
    section: 'A.4 Trading Risk Control',
    roles: ['Analyst', 'Quant'],
    domains: ['Basis Risk', 'Hedging'],
    riskType: 'Market Risk',
    complexity: 'Configurable',
    outputTypes: ['Heatmap Spec', 'Desk Actions'],
    variables: [
      { name: 'hedge_pairs', type: 'textarea', default: 'CDX IG vs cash bonds, SOFR vs Fed Funds futures, Brent vs WTI crack, STOXX futures vs basket hedges' },
      { name: 'lookback_period', type: 'select', options: ['6M', '1Y', '2Y', '5Y'], default: '2Y' },
      { name: 'stress_windows', type: 'textarea', default: 'Mar-2020, Sep-2022, Mar-2023' },
    ],
    prompt: `You are a cross-asset risk analyst.
Generate a basis risk heatmap framework for:
- Hedge pairs: {{hedge_pairs}}
- Lookback: {{lookback_period}}
- Stress windows: {{stress_windows}}

Deliver:
1. Pair-level basis distribution diagnostics (level, volatility, skew, jump intensity).
2. Regime-conditioned basis beta estimates and breakdown points.
3. Liquidity-adjusted basis stress assumptions and haircut tables.
4. Top-10 positions most exposed to basis widening with sensitivity attribution.
5. Mitigation options ranked by cost, liquidity, and expected effectiveness.

Format: Heatmap-ready dataset design plus interpretation guide and desk action recommendations.`,
  }),
  mk({
    id: 'A.4.4',
    title: 'FRTB PLA Investigation Generator',
    category: 'Market Risk',
    section: 'A.4 Trading Risk Control',
    roles: ['Validator', 'Quant', 'Compliance'],
    domains: ['FRTB', 'P&L Attribution Test'],
    riskType: 'Market Risk',
    complexity: 'Deep Build',
    regulatory: ['FRTB'],
    complianceTag: 'Regulatory Submission Ready',
    outputTypes: ['Regulatory Memo', 'Issue Log'],
    variables: [
      { name: 'desk_id', type: 'text', default: 'EQX-NA-02' },
      { name: 'pla_window', type: 'select', options: ['3M', '6M', '12M'], default: '12M' },
      { name: 'rtpl_hpl_gaps', type: 'textarea', default: 'RTPL-HPL correlation 0.67; unexplained component 23%' },
    ],
    prompt: `You are leading a desk-level FRTB PLA investigation for desk {{desk_id}}.
Assessment window: {{pla_window}}.
Observed gap metrics: {{rtpl_hpl_gaps}}.

Produce a regulator-ready investigation that includes:
1. Test outcome decomposition and threshold breach diagnosis.
2. Data lineage checks for risk-theoretical and hypothetical P&L components.
3. Model coverage gaps by product and risk factor, including residual buckets.
4. Remediation options with expected impact on PLA metrics and implementation risk.
5. Capital impact scenario if desk remains in amber/red test outcomes.
6. Governance timeline for resubmission and evidence package requirements.

Format: Formal investigation memo with appendices for controls, quantitative diagnostics, and remediation ownership.`,
  }),
  mk({
    id: 'A.4.5',
    title: 'NMRF Remediation Strategy Prompt',
    category: 'Market Risk',
    section: 'A.4 Trading Risk Control',
    roles: ['Quant', 'Compliance'],
    domains: ['FRTB', 'NMRF', 'Data Strategy'],
    riskType: 'Market Risk',
    complexity: 'Deep Build',
    regulatory: ['FRTB'],
    outputTypes: ['Strategy Paper', 'Execution Plan'],
    variables: [
      { name: 'nrmf_population', type: 'text', default: '428 factors across rates vol and EM credit basis' },
      { name: 'modellability_fail_reason', type: 'textarea', default: 'Insufficient real-price observations and fragmented venue liquidity' },
      { name: 'capital_penalty', type: 'text', default: '+USD 410mm RWA equivalent' },
    ],
    prompt: `You are responsible for reducing FRTB non-modellable risk factors (NMRFs).
Current population: {{nrmf_population}}.
Primary fail reason: {{modellability_fail_reason}}.
Estimated capital penalty: {{capital_penalty}}.

Build a full remediation strategy:
1. Root-cause taxonomy for modellability failure by asset class.
2. Data acquisition options (venues, contributors, broker quotes) with legal/operational constraints.
3. Internal observation capture design and control framework to satisfy real-price criteria.
4. Proxying strategy where modellability is structurally unattainable, including validation controls.
5. Expected capital benefit vs delivery cost and timeline by remediation stream.
6. Governance model for quarterly NMRF steering and regulator communication.

Format: Strategy and execution plan with quantified business case and dependency map.`,
  }),
  mk({
    id: 'A.4.6',
    title: 'Trading Desk Limit Recalibration Prompt',
    category: 'Market Risk',
    section: 'A.4 Trading Risk Control',
    roles: ['Senior Leader', 'Analyst'],
    domains: ['Risk Limits', 'Governance'],
    riskType: 'Market Risk',
    complexity: 'Configurable',
    outputTypes: ['Limit Proposal', 'Governance Pack'],
    variables: [
      { name: 'desk_universe', type: 'textarea', default: 'Rates Macro, Credit Trading, Equity Derivatives, FX Options' },
      { name: 'capital_target', type: 'text', default: '11.5% CET1 utilization envelope' },
      { name: 'risk_appetite_shift', type: 'textarea', default: 'Board has tightened downside tolerance and reduced concentration appetite' },
    ],
    prompt: `You are preparing an annual market risk limit recalibration proposal.
Desk universe: {{desk_universe}}.
Capital target: {{capital_target}}.
Risk appetite update: {{risk_appetite_shift}}.

Generate a limit recalibration framework covering:
1. Baseline diagnostics: current utilization, breach frequency, stress loss distribution, and P&L/risk efficiency.
2. Allocation engine: proposed desk-level VaR, stress, and sensitivity limits using revenue, volatility, and diversification contribution.
3. Buffers and flexibility: reserve pools for new business and contingency actions.
4. Escalation logic: green/yellow/red thresholds, temporary excess rules, and automatic de-risk triggers.
5. Impact analysis: expected changes in revenue-at-risk, capital, and tail-loss profile.
6. Governance pack: challenge questions, sign-off workflow, and quarterly recalibration checkpoints.

Format: Decision-ready proposal with quantitative tables, rationale, and implementation timeline.`,
  }),
];

const creditPrompts = [
  mk({
    id: 'B.1',
    title: 'PD/LGD/EAD Model Development Specification',
    category: 'Credit & Counterparty Risk',
    section: 'B.1 Model Development',
    roles: ['Quant', 'Analyst', 'Validator'],
    domains: ['Credit Modeling', 'IRB', 'Model Development'],
    riskType: 'Credit Risk',
    complexity: 'Deep Build',
    regulatory: ['Basel IRB', 'CECL', 'IFRS 9', 'SR 11-7'],
    complianceTag: 'Regulatory Submission Ready',
    outputTypes: ['MDD', 'Methodology Comparison'],
    variables: [
      { name: 'model_component', type: 'select', options: ['PD', 'LGD', 'EAD'], default: 'PD' },
      {
        name: 'segment',
        type: 'select',
        options: ['Large Corporate', 'Mid-Market', 'Financial Institutions', 'Sovereign', 'Project Finance', 'Commercial Real Estate', 'Leveraged Lending'],
        default: 'Large Corporate',
      },
      { name: 'num_obligors', type: 'text', default: '42,000' },
      { name: 'total_exposure', type: 'text', default: 'USD 186bn' },
      { name: 'default_data_description', type: 'textarea', default: '12 years internal default panel + external bureau enrichment' },
      { name: 'current_model_description', type: 'text', default: 'Legacy scorecard with TTC calibration' },
    ],
    related: ['B.10', 'C.3'],
    prompt: `You are the lead credit risk modeler developing a {{model_component}} model for the
{{segment}} portfolio within CIB.

Portfolio characteristics:
- Number of obligors: {{num_obligors}}
- Total exposure: {{total_exposure}}
- Historical default data: {{default_data_description}}
- Current model (if replacing): {{current_model_description}}

Build the complete model development specification:

1. Literature Review and Methodology Selection:
   - Survey the current state-of-the-art for {{model_component}} modeling in {{segment}}
   - Compare candidate methodologies:
     {{#if model_component == "PD"}}
     a) Logistic regression (with variable selection: stepwise, LASSO, elastic net)
     b) Structural models (Merton, KMV-style distance-to-default)
     c) Reduced-form hazard rate models (Cox PH, discrete-time survival)
     d) Machine learning approaches (XGBoost, random forest) with interpretability layers (SHAP)
     e) Expert judgment / scorecard hybrid approaches
     {{/if}}
     {{#if model_component == "LGD"}}
     a) Beta regression
     b) Two-stage models (workout vs. liquidation) with fractional response
     c) Tobit / censored regression approaches
     d) Non-parametric approaches for bimodal LGD distributions
     e) Downturn LGD estimation methodologies
     {{/if}}
     {{#if model_component == "EAD"}}
     a) Credit Conversion Factor (CCF) regression models
     b) Momentum models for drawdown behavior
     c) Loan-equivalent exposure for derivatives (EPE, EEPE)
     d) SA-CCR vs. IMM approaches for counterparty exposure
     {{/if}}
   - For each methodology: assumptions, data requirements, advantages, limitations,
     regulatory acceptability (Basel IRB, CECL, IFRS 9)

2. Data Requirements and Feature Engineering:
   - Minimum data requirements (sample size, history length, default/loss observations)
   - Feature candidate list organized by category:
     a) Financial statement variables
     b) Market-based indicators
     c) Behavioral/transactional features
     d) Macroeconomic variables
     e) Industry/sector variables
   - Feature engineering techniques specific to {{segment}}
   - Missing data treatment strategy
   - Outlier detection and treatment

3. Model Development Workflow:
   - Sample design (development, validation, out-of-time holdout)
   - Variable selection process with statistical criteria
   - Model estimation with hyperparameter tuning approach
   - In-sample performance metrics:
     {{#if model_component == "PD"}}
     AUC/Gini, KS statistic, Information Value, Hosmer-Lemeshow, Brier Score
     {{/if}}
     {{#if model_component == "LGD"}}
     R, MAE, RMSE, calibration by bucket, distribution fit tests
     {{/if}}
   - Out-of-sample and out-of-time validation results
   - Benchmarking against {{current_model_description}} (if applicable)

4. Regulatory Compliance Checks:
   - Basel IRB minimum requirements checklist
   - CECL/IFRS 9 specific requirements (if applicable)
   - Use test demonstration
   - Conservatism assessment and margin of conservatism calculation
   - Through-the-cycle vs. point-in-time calibration considerations

5. Model Documentation Outline:
   - Complete model documentation structure per SR 11-7
   - Key sections and what each must contain
   - Effective challenge evidence requirements

Format: Model Development Document (MDD) framework with all sections outlined,
key analyses specified, and regulatory compliance mapping.`,
  }),
  mk({
    id: 'B.2',
    title: 'CVA/DVA/FVA Comprehensive Framework',
    category: 'Credit & Counterparty Risk',
    section: 'B.2 XVA Analytics',
    roles: ['Quant', 'Analyst', 'Senior Leader'],
    domains: ['Counterparty Risk', 'XVA', 'Simulation'],
    riskType: 'Counterparty Risk',
    complexity: 'Deep Build',
    outputTypes: ['Quant Spec', 'Architecture Diagram'],
    regulatory: ['SA-CVA', 'BA-CVA', 'SA-CCR'],
    variables: [
      { name: 'xva_component', type: 'select', options: ['CVA', 'DVA', 'FVA', 'Bilateral XVA'], default: 'CVA' },
      { name: 'num_counterparties', type: 'number', default: 2300 },
      { name: 'num_netting_sets', type: 'number', default: 6100 },
      { name: 'total_notional', type: 'text', default: 'USD 9.8T' },
      { name: 'product_mix', type: 'textarea', default: 'Rates swaps, swaptions, FX forwards/options, CDS indices, equity swaps' },
      { name: 'csa_coverage', type: 'number', default: 84 },
    ],
    related: ['B.3', 'C.2'],
    prompt: `You are a senior XVA quant building the analytical framework for the
{{xva_component}} calculation across the CIB derivatives portfolio.

Portfolio scope:
- Number of counterparties: {{num_counterparties}}
- Number of netting sets: {{num_netting_sets}}
- Total notional: {{total_notional}}
- Product mix: {{product_mix}}
- CSA coverage: {{csa_coverage}}%

Build the complete {{xva_component}} framework:

1. Mathematical Formulation:
   - Write out the complete {{xva_component}} formula with all terms defined
   - Expected Exposure (EE) and Expected Negative Exposure (ENE) calculation methodology
   - Default probability term structure modeling
   - Recovery rate assumptions and sensitivity
   - Discount rate selection (OIS, CSA rate, funding rate - justify choice)
   - For bilateral XVA: own-default component treatment

2. Exposure Simulation Engine:
   - Monte Carlo simulation architecture for portfolio-level exposure profiles
   - Risk factor evolution models:
     a) Interest rate models (Hull-White, LGM, multi-factor)
     b) FX models (geometric Brownian motion with stochastic vol?)
     c) Credit spread models (CIR++, jump-diffusion)
     d) Equity models (local vol, stochastic vol)
   - Correlation modeling between risk factors (and between risk factors and default)
   - Netting set aggregation logic
   - Collateral simulation (CSA terms: threshold, MTA, rounding, remargin frequency, cure period)
   - Margin Period of Risk (MPR) assumptions by netting set type

3. Wrong-Way Risk:
   - General wrong-way risk: correlation between counterparty credit quality and exposure
   - Specific wrong-way risk: direct link between exposure and counterparty default
   - Modeling approaches: copula-based, structural, jump-to-default
   - Impact quantification and regulatory requirements (SA-CVA vs. BA-CVA vs. IMA-CVA)

4. Sensitivity and Hedging:
   - CVA sensitivities: CS01, EE01, rate sensitivities
   - CVA hedging strategy: CDS hedges, contingent CDS, macro hedges
   - Hedge effectiveness measurement
   - CVA P&L explain framework

5. Regulatory Capital:
   - SA-CVA calculation methodology
   - BA-CVA calculation methodology
   - IMA-CVA (if applicable): internal model approach specification
   - Comparison of capital charges across approaches

Format: Quantitative specification document with complete mathematical derivations,
simulation architecture diagrams, and implementation notes.`,
  }),
  mk({
    id: 'B.3',
    title: 'Counterparty Credit Risk Monitoring Dashboard Specification',
    category: 'Credit & Counterparty Risk',
    section: 'B.3 Monitoring',
    roles: ['Analyst', 'Senior Leader', 'Data Engineer'],
    domains: ['Counterparty Risk', 'Monitoring', 'Dashboards'],
    riskType: 'Counterparty Risk',
    complexity: 'Configurable',
    outputTypes: ['System Requirements', 'Wireframe'],
    variables: [{ name: 'top_n_counterparties', type: 'number', default: 50 }],
    prompt: `You are designing the real-time counterparty credit risk monitoring framework
for the CIB portfolio.

Specify the complete monitoring system:

1. Counterparty-Level Metrics (for each of top {{top_n_counterparties}} counterparties):
   - Current exposure (CE), Potential Future Exposure (PFE) at 95th and 99th percentile
   - Peak PFE and time-to-peak
   - Expected Exposure (EE) and Effective EE profiles
   - CVA and CVA sensitivity to spread moves
   - Collateral position: posted, received, net, headroom to threshold
   - Wrong-way risk indicators
   - Credit quality indicators: rating, CDS spread, equity price, news sentiment
   - Limit utilization: CE/limit, PFE/limit, with traffic light status

2. Portfolio-Level Aggregations:
   - Total counterparty credit risk exposure by region, sector, rating bucket
   - Concentration metrics: Herfindahl index, top-10 exposure share
   - Correlation risk: what happens if all counterparties in a sector deteriorate simultaneously?
   - Margin call forecast under stress (total liquidity demand)
   - CVA P&L attribution and hedging effectiveness

3. Early Warning System:
   - Define 10+ quantitative early warning indicators with specific thresholds
   - Credit spread moves (absolute, relative, sector-relative)
   - CDS-equity basis signals
   - Rating agency watch/outlook changes
   - Peer comparison deterioration
   - Payment behavior changes
   - News/sentiment scoring integration
   - Escalation matrix: which indicators trigger which actions at which levels

4. Stress Testing Integration:
   - How counterparty credit risk changes under CCAR scenarios
   - Joint stress: market risk + counterparty default scenarios
   - Systemic risk scenarios (multiple counterparty failures)
   - Central counterparty (CCP) stress scenarios

Format: System requirements document with wireframe specifications, data flow
diagrams, alerting logic, and API specifications for real-time data feeds.`,
  }),
  mk({
    id: 'B.4',
    title: 'Wrong-Way Risk Deep Diagnostic Prompt',
    category: 'Credit & Counterparty Risk',
    section: 'B.4 Diagnostics',
    roles: ['Quant', 'Validator'],
    domains: ['Wrong-Way Risk', 'XVA'],
    riskType: 'Counterparty Risk',
    complexity: 'Deep Build',
    outputTypes: ['Diagnostic Report', 'Mitigation Plan'],
    variables: [
      { name: 'counterparty_segment', type: 'text', default: 'Commodity producers and EM sovereign-linked banks' },
      { name: 'exposure_profile', type: 'textarea', default: 'Long commodity swaps and FX options with concentrated tenor profile in 1Y-3Y' },
    ],
    prompt: `You are performing a deep wrong-way risk diagnostic.
Scope: {{counterparty_segment}}.
Exposure profile: {{exposure_profile}}.

Deliver:
1. General and specific WWR hypothesis map, including causal mechanisms.
2. Quantitative tests: exposure-credit spread dependence, tail co-exceedance,
   scenario-based default/exposure coupling.
3. Model comparison: independent simulation baseline vs copula/structural/jump-linked WWR models.
4. Capital and CVA sensitivity to WWR assumptions.
5. Hedge and mitigation options with basis/liquidity considerations.

Format: Validation-grade diagnostic with formulas, test outputs, and prioritized remediation actions.`,
  }),
  mk({
    id: 'B.5',
    title: 'Credit Migration Transition Matrix Calibration Prompt',
    category: 'Credit & Counterparty Risk',
    section: 'B.4 Diagnostics',
    roles: ['Quant', 'Analyst'],
    domains: ['Credit Migration', 'Transition Matrices'],
    riskType: 'Credit Risk',
    complexity: 'Configurable',
    outputTypes: ['Method Note', 'Calibration Table'],
    variables: [
      { name: 'rating_universe', type: 'text', default: 'AAA to D, global corporates' },
      { name: 'horizon', type: 'select', options: ['1Y', '2Y', '5Y'], default: '1Y' },
      { name: 'cycle_overlay', type: 'textarea', default: 'Late-cycle tightening with recession risk in 6-12 months' },
    ],
    prompt: `You are calibrating a transition matrix for {{rating_universe}} at {{horizon}} horizon.
Macro-cycle overlay: {{cycle_overlay}}.

Construct a calibration protocol covering cohort vs duration approaches,
point-in-time vs through-the-cycle mapping, smoothing constraints,
rare-transition stabilization, and macro-conditioned stress overlays.
Include validation tests for row normalization, monotonic credit quality drift,
and out-of-time predictive performance.

Format: Technical calibration memo with equations, calibration choices, and monitoring triggers.`,
  }),
  mk({
    id: 'B.6',
    title: 'Expected Credit Loss Macro Overlay Challenge Prompt',
    category: 'Credit & Counterparty Risk',
    section: 'B.4 Diagnostics',
    roles: ['Analyst', 'Validator', 'Compliance'],
    domains: ['ECL', 'Macro Overlays', 'Governance'],
    riskType: 'Credit Risk',
    complexity: 'Configurable',
    outputTypes: ['Challenge Memo', 'Overlay Decision Log'],
    variables: [
      { name: 'base_ecl', type: 'text', default: 'USD 2.1bn' },
      { name: 'proposed_overlay', type: 'text', default: 'USD +310mm management overlay' },
      { name: 'overlay_drivers', type: 'textarea', default: 'Commercial real estate refinancing wall and lagged covenant deterioration' },
    ],
    prompt: `You are independently challenging a management ECL macro overlay proposal.
Base ECL: {{base_ecl}}.
Proposed overlay: {{proposed_overlay}}.
Rationale: {{overlay_drivers}}.

Provide a structured challenge that tests empirical support,
consistency with scenario weighting, double-counting risk,
segment-level calibration coherence, and governance sufficiency.
Recommend accept/adjust/reject with quantified alternative overlay range.

Format: Governance-ready challenge memo with decision rationale and evidence checklist.`,
  }),
  mk({
    id: 'B.7',
    title: 'Counterparty Limit Optimization Engine Prompt',
    category: 'Credit & Counterparty Risk',
    section: 'B.5 Portfolio Controls',
    roles: ['Senior Leader', 'Analyst'],
    domains: ['Counterparty Limits', 'Optimization'],
    riskType: 'Counterparty Risk',
    complexity: 'Deep Build',
    outputTypes: ['Optimization Blueprint', 'Decision Table'],
    variables: [
      { name: 'limit_budget', type: 'text', default: 'USD 48bn gross PFE limit budget' },
      { name: 'business_objective', type: 'textarea', default: 'Maximize expected client revenue subject to CVA volatility and concentration constraints' },
    ],
    prompt: `Design a counterparty limit optimization framework.
Constraint budget: {{limit_budget}}.
Objective: {{business_objective}}.

Include:
1. Objective function and constraints (capital, concentration, wrong-way risk, liquidity).
2. Required inputs and data quality controls.
3. Optimization approach (deterministic, stochastic, or robust optimization).
4. Trade-off frontier between revenue, capital, and tail loss.
5. Governance for limit resets and emergency reallocation.

Format: Quantitative policy blueprint with implementation-ready formulas and decision outputs.`,
  }),
  mk({
    id: 'B.8',
    title: 'Netting and CSA Remediation Planner Prompt',
    category: 'Credit & Counterparty Risk',
    section: 'B.5 Portfolio Controls',
    roles: ['Analyst', 'Senior Leader'],
    domains: ['CSA', 'Netting', 'Legal Risk'],
    riskType: 'Counterparty Risk',
    complexity: 'Configurable',
    outputTypes: ['Remediation Plan'],
    variables: [
      { name: 'legacy_population', type: 'text', default: '1,120 netting sets with non-standard CSA terms' },
      { name: 'pain_points', type: 'textarea', default: 'High thresholds, infrequent remargin, collateral type asymmetry, cure-period ambiguity' },
    ],
    prompt: `You are remediating legacy legal terms for counterparty risk.
Population: {{legacy_population}}.
Key pain points: {{pain_points}}.

Create a remediation plan that prioritizes legal renegotiation,
quantifies exposure reduction by clause amendment,
establishes negotiation sequencing by impact and feasibility,
and defines interim controls pending legal completion.

Format: Execution plan with phased milestones, expected risk reduction, and owner accountability.`,
  }),
  mk({
    id: 'B.9',
    title: 'Sovereign and Financial Contagion Stress Builder',
    category: 'Credit & Counterparty Risk',
    section: 'B.5 Portfolio Controls',
    roles: ['Quant', 'Analyst', 'Senior Leader'],
    domains: ['Contagion', 'Stress Testing'],
    riskType: 'Credit Risk',
    complexity: 'Deep Build',
    outputTypes: ['Scenario Set', 'Impact Matrix'],
    variables: [
      { name: 'trigger_country', type: 'text', default: 'Italy' },
      { name: 'contagion_channels', type: 'textarea', default: 'Sovereign spreads, bank CDS, FX depreciation, repo haircuts, collateral contagion' },
    ],
    prompt: `Build a contagion stress framework starting from {{trigger_country}} shock.
Transmission channels: {{contagion_channels}}.

Develop multi-stage scenarios linking sovereign stress to financial sector spread widening,
funding stress, collateral value deterioration, and counterparty migration/default.
Quantify incremental exposure and CVA impact at each stage and propose mitigation triggers.

Format: Scenario architecture with channel-by-channel equations, timeline assumptions, and action thresholds.`,
  }),
  mk({
    id: 'B.10',
    title: 'Defaulted Asset Workout LGD Playbook Prompt',
    category: 'Credit & Counterparty Risk',
    section: 'B.6 Workout & Recovery',
    roles: ['Analyst', 'Senior Leader'],
    domains: ['Workout', 'LGD', 'Recovery'],
    riskType: 'Credit Risk',
    complexity: 'Configurable',
    outputTypes: ['Workout Playbook', 'Recovery Dashboard'],
    variables: [
      { name: 'defaulted_pool', type: 'text', default: 'USD 3.4bn leveraged loans and project finance exposures' },
      { name: 'jurisdictions', type: 'textarea', default: 'US, UK, Germany, Brazil' },
      { name: 'recovery_objective', type: 'text', default: 'Maximize NPV recovery with 24-month resolution target' },
    ],
    prompt: `You are creating a workout strategy for {{defaulted_pool}} across {{jurisdictions}}.
Objective: {{recovery_objective}}.

Produce a complete LGD/workout playbook:
1. Segmentation by collateral quality, legal route, and borrower viability.
2. Decision tree for restructuring vs liquidation vs secondary sale.
3. Jurisdiction-specific legal timing assumptions and uncertainty ranges.
4. Recovery waterfall modeling and expected cash timing profile.
5. Governance cadence and performance KPIs.

Format: Actionable workout playbook with scenario-based recovery expectations and execution checkpoints.`,
  }),
];

const regulatoryPrompts = [
  mk({
    id: 'C.1',
    title: 'CCAR/DFAST Submission Playbook Generator',
    category: 'Regulatory & Capital',
    section: 'C.1 Submission Management',
    roles: ['Senior Leader', 'Analyst', 'Compliance'],
    domains: ['CCAR', 'DFAST', 'Program Management'],
    riskType: 'Regulatory Capital',
    complexity: 'Deep Build',
    regulatory: ['CCAR', 'DFAST', 'SR 11-7'],
    complianceTag: 'Regulatory Submission Ready',
    outputTypes: ['Playbook', 'RACI', 'Gantt Data'],
    variables: [
      { name: 'submission_cycle', type: 'text', default: '2026' },
      { name: 'submission_date', type: 'date', default: '2026-04-05' },
    ],
    related: ['A.2.1', 'G.5'],
    prompt: `You are the program lead for the CIB Risk contribution to the bank's
{{submission_cycle}} CCAR/DFAST submission.

Generate a comprehensive playbook covering:

1. Timeline and Milestone Tracker:
   Build the complete submission timeline working backward from the
   {{submission_date}} filing deadline:
   - Fed scenario release processing (T-minus XX weeks)
   - Scenario translation and risk factor shock generation
   - Model runs (market risk, credit risk, counterparty risk, operational risk)
   - Results aggregation and quality assurance
   - Narrative drafting and review cycles
   - Senior management challenge sessions
   - Board review and approval
   - Filing and post-filing processes
   Assign specific dates, owners, and dependencies for each milestone.

2. CIB-Specific Model Run Specifications:
   For each model category that contributes to CIB's CCAR results:
   - Pre-run checklist (data freshness, model version confirmation, parameter lock)
   - Run specifications (which scenarios, which portfolios, which time horizons)
   - Output format and quality checks
   - Reconciliation to prior quarter and prior year results
   - Materiality thresholds for variance investigation

3. Challenge and Governance Framework:
   - First line of defense: desk-level review of inputs and results
   - Second line of defense: independent risk review and challenge questions
   - Model Risk: validation of all models in the CCAR chain
   - Senior management challenge: prepare for CRO and CEO challenge sessions
   - Board presentation: key messages, risk narratives, capital impact summary
   - Prepare 50 likely challenge questions with draft responses

4. Narrative Requirements:
   - Qualitative narrative structure for CIB risk contribution
   - Key themes to address: methodology changes, portfolio changes,
     scenario sensitivity, risk factor coverage
   - How to explain counterintuitive results
   - Comparison to prior cycle results with variance explanations

5. Quality Assurance Protocol:
   - Data integrity checks (position data, market data, reference data)
   - Model output reasonableness checks (bounds, signs, magnitudes)
   - Cross-model consistency checks
   - Aggregation and double-counting checks
   - Final submission review checklist

Format: Project management playbook with Gantt chart data, RACI matrices,
checklist templates, and narrative outlines.`,
  }),
  mk({
    id: 'C.2',
    title: 'Basel III/IV Capital Calculation Engine Prompt',
    category: 'Regulatory & Capital',
    section: 'C.2 Capital Calculations',
    roles: ['Analyst', 'Quant', 'Compliance'],
    domains: ['Basel Capital', 'FRTB', 'SA-CCR', 'CVA'],
    riskType: 'Regulatory Capital',
    complexity: 'Deep Build',
    regulatory: ['Basel III', 'Basel IV', 'FRTB'],
    complianceTag: 'Regulatory Submission Ready',
    outputTypes: ['Calculation Workbook', 'Optimization Recommendations'],
    variables: [
      {
        name: 'capital_component',
        type: 'select',
        options: ['Market Risk Capital (FRTB)', 'Counterparty Credit Risk Capital', 'CVA Capital', 'Credit Risk (IRB)', 'Operational Risk'],
        default: 'Market Risk Capital (FRTB)',
      },
      { name: 'regulatory_framework', type: 'select', options: ['Basel III Current', 'Basel III Endgame / Basel IV', 'Transitional'], default: 'Basel III Endgame / Basel IV' },
      { name: 'portfolio_description', type: 'textarea', default: 'Cross-asset trading book with rates options, credit index tranches, FX exotics, and commodity structures' },
    ],
    related: ['A.4.4', 'C.4'],
    prompt: `You are a regulatory capital specialist computing the {{capital_component}}
for the CIB trading book under {{regulatory_framework}}.

Portfolio composition:
{{portfolio_description}}

Produce the complete calculation framework:

{{#if capital_component == "Market Risk Capital (FRTB)"}}
1. Standardized Approach (SA):
   - Sensitivities-Based Method (SbM): Delta, Vega, Curvature for each risk class
   - Risk class breakdown: GIRR, CSR (non-securitization), CSR (securitization),
     Equity, Commodity, FX
   - Risk weight tables and correlation parameters for each risk class
   - Aggregation across buckets and risk classes
   - Default Risk Charge (DRC) calculation
   - Residual Risk Add-On (RRAO) for exotic exposures
   - Complete worked example with numbers

2. Internal Models Approach (IMA) (if applicable):
   - Expected Shortfall (ES) calculation replacing VaR
   - Liquidity horizons by risk factor (10d, 20d, 40d, 60d, 120d)
   - ES aggregation with varying liquidity horizons
   - Stress calibration and reduced set of risk factors
   - P&L attribution test (PLAT) specification
   - Risk factor eligibility test (RFET)
   - Capital calculation: max(previous day ES, 60-day avg ES  multiplier) + DRC + SES
   - Conditions for desk-level IMA approval vs. fallback to SA

3. Boundary and Classification:
   - Trading book / banking book boundary rules
   - Internal risk transfer (IRT) treatment
   - Positions subject to both credit risk and market risk capital
{{/if}}

{{#if capital_component == "Counterparty Credit Risk Capital"}}
1. SA-CCR Calculation:
   - Replacement cost (RC) calculation: current MTM, collateral, net of margin
   - Potential Future Exposure (PFE) add-on by asset class
   - Alpha multiplier
   - Netting and collateral recognition rules
   - Hedging set construction
   - Complete worked example

2. CVA Capital:
   - BA-CVA vs. SA-CVA methodology
   - Eligible hedges and hedge recognition
   - Calculation for each counterparty
   - Aggregation methodology
{{/if}}

4. Optimization Analysis:
   - Which positions contribute most to capital?
   - Marginal capital by trade/desk
   - Capital-efficient restructuring opportunities
   - Impact of netting and collateral optimization

Format: Regulatory calculation workbook with step-by-step computations,
regulatory references (specific Basel paragraph numbers), and optimization recommendations.`,
  }),
  mk({
    id: 'C.3',
    title: 'SR 11-7 Model Risk Management Compliance Audit',
    category: 'Regulatory & Capital',
    section: 'C.3 Audit and Compliance',
    roles: ['Compliance', 'Validator', 'Senior Leader'],
    domains: ['Model Risk Governance', 'Audit'],
    riskType: 'Model Risk',
    complexity: 'Deep Build',
    regulatory: ['SR 11-7', 'OCC 2011-12'],
    complianceTag: 'Regulatory Submission Ready',
    outputTypes: ['Audit Workpaper', 'Remediation Roadmap'],
    prompt: `You are an internal audit specialist assessing the CIB Risk organization's
compliance with SR 11-7 / OCC 2011-12 model risk management guidance.

Produce a comprehensive audit framework:

1. Model Inventory Completeness:
   - Criteria for what constitutes a \"model\" under SR 11-7
   - Assessment checklist for completeness of the model inventory
   - Common gaps: spreadsheet models, vendor models, challenger models,
     end-user computing (EUC) tools
   - Risk-based approach to model identification and tiering

2. Model Development Standards:
   For each model in the inventory, assess:
   - Documented theoretical basis and methodology
   - Data quality and representativeness documentation
   - Assumption inventory with justification
   - Limitations and compensating controls documentation
   - Developer testing evidence
   - Management approval documentation

3. Model Validation Standards:
   - Independence of validation function
   - Validation scope and rigor relative to model tier
   - Conceptual soundness review evidence
   - Outcomes analysis (backtesting, benchmarking)
   - Ongoing monitoring program
   - Validation report quality assessment criteria
   - Finding management process (MRA/MRIA lifecycle)

4. Model Use and Governance:
   - Approved use documentation
   - Use outside approved scope detection
   - Model output override governance
   - Model change management process
   - Annual review and re-attestation process
   - Board and senior management reporting

5. Remediation Roadmap Generator:
   For each gap identified, produce:
   - Severity classification (Critical / High / Medium / Low)
   - Root cause analysis
   - Specific remediation actions
   - Estimated effort and timeline
   - Owner assignment recommendation
   - Interim compensating controls

Format: Audit workpaper template with testing procedures, evidence requirements,
and finding templates aligned to OCC examination standards.`,
  }),
  mk({
    id: 'C.4',
    title: 'FRTB IMA Desk Approval Readiness Prompt',
    category: 'Regulatory & Capital',
    section: 'C.2 Capital Calculations',
    roles: ['Quant', 'Compliance', 'Senior Leader'],
    domains: ['FRTB', 'IMA'],
    riskType: 'Regulatory Capital',
    complexity: 'Deep Build',
    regulatory: ['FRTB'],
    complianceTag: 'Regulatory Submission Ready',
    outputTypes: ['Readiness Assessment'],
    variables: [
      { name: 'desk_portfolio', type: 'text', default: 'Global Rates Options' },
      { name: 'recent_plat_results', type: 'textarea', default: '2 amber, 1 red in last 12 observations' },
      { name: 'rfet_status', type: 'textarea', default: '91% modellable by stressed ES contribution; EM basis factors lagging' },
    ],
    prompt: `Assess IMA readiness for desk {{desk_portfolio}}.
PLAT results: {{recent_plat_results}}.
RFET status: {{rfet_status}}.

Produce a readiness assessment covering quantitative test stability,
control framework maturity, remediation backlog, fallback SA capital impact,
and regulator challenge preparedness.

Format: Executive and technical assessment with go/no-go recommendation and action plan.`,
  }),
  mk({
    id: 'C.5',
    title: 'ICAAP Risk Appetite Capital Linkage Prompt',
    category: 'Regulatory & Capital',
    section: 'C.4 Strategic Capital',
    roles: ['Senior Leader', 'Analyst', 'Compliance'],
    domains: ['ICAAP', 'Risk Appetite', 'Capital Planning'],
    riskType: 'Regulatory Capital',
    complexity: 'Configurable',
    outputTypes: ['Policy Note', 'Mapping Tables'],
    variables: [
      { name: 'icaap_horizon', type: 'select', options: ['1Y', '3Y'], default: '3Y' },
      { name: 'capital_buffers', type: 'text', default: 'Management buffer 150bps over regulatory minimums' },
    ],
    prompt: `Design an ICAAP linkage between risk appetite and capital planning over {{icaap_horizon}}.
Buffer policy: {{capital_buffers}}.

Deliver a framework mapping risk appetite metrics to capital consumption,
stress outcomes, and management actions under deteriorating scenarios,
including governance and board reporting design.

Format: Policy and analytics framework with mapping matrices and triggers.`,
  }),
  mk({
    id: 'C.6',
    title: 'Recovery and Resolution Capital Playbook Prompt',
    category: 'Regulatory & Capital',
    section: 'C.4 Strategic Capital',
    roles: ['Senior Leader', 'Compliance'],
    domains: ['Recovery Planning', 'Resolution'],
    riskType: 'Regulatory Capital',
    complexity: 'Deep Build',
    outputTypes: ['Playbook'],
    variables: [
      { name: 'stress_trigger_set', type: 'textarea', default: 'Capital ratio breach trajectory, liquidity stress, rating downgrade cascade' },
      { name: 'critical_businesses', type: 'textarea', default: 'Rates market-making, repo financing, FX prime services' },
    ],
    prompt: `Build a recovery and resolution capital playbook.
Stress triggers: {{stress_trigger_set}}.
Critical businesses: {{critical_businesses}}.

Include trigger calibration, recovery options by phase,
execution feasibility under market stress, and communication/protocol requirements with supervisors.

Format: Actionable playbook with decision trees, owners, and timing assumptions.`,
  }),
  mk({
    id: 'C.7',
    title: 'Regulatory Change Impact Tracker Prompt',
    category: 'Regulatory & Capital',
    section: 'C.5 Regulatory Change',
    roles: ['Compliance', 'Senior Leader', 'Analyst'],
    domains: ['Regulatory Change', 'Program Tracking'],
    riskType: 'Regulatory Risk',
    complexity: 'Quick Use',
    outputTypes: ['Tracker Template', 'Impact Memo'],
    variables: [
      { name: 'regulatory_changes', type: 'textarea', default: 'Basel III Endgame implementation, SEC climate disclosure, UK PRA model risk updates' },
      { name: 'implementation_window', type: 'text', default: '2026-2028' },
    ],
    prompt: `Create a regulatory change impact tracker.
Changes: {{regulatory_changes}}.
Window: {{implementation_window}}.

Provide impact scoring across capital, systems, governance,
required workstreams, and executive decision points.

Format: Portfolio tracker with RAG status, dependencies, and escalation criteria.`,
  }),
  mk({
    id: 'C.8',
    title: 'Pillar 3 Disclosure Draft Assistant Prompt',
    category: 'Regulatory & Capital',
    section: 'C.5 Regulatory Change',
    roles: ['Compliance', 'Senior Leader'],
    domains: ['Pillar 3', 'Disclosure'],
    riskType: 'Regulatory Reporting',
    complexity: 'Configurable',
    outputTypes: ['Disclosure Draft', 'QA Checklist'],
    variables: [
      { name: 'reporting_period', type: 'text', default: 'Q4 2026' },
      { name: 'material_changes', type: 'textarea', default: 'FRTB implementation, CVA hedge program update, concentration shift in energy portfolio' },
    ],
    prompt: `Draft a Pillar 3 narrative for {{reporting_period}}.
Material changes: {{material_changes}}.

Generate a disclosure structure with technical accuracy, comparability to prior period,
clear variance explanations, and QA controls for consistency with regulatory returns.

Format: Draft-ready disclosure narrative and validation checklist.`,
  }),
  mk({
    id: 'C.9',
    title: 'Internal Capital Allocation and RoRC Engine Prompt',
    category: 'Regulatory & Capital',
    section: 'C.4 Strategic Capital',
    roles: ['Senior Leader', 'Analyst'],
    domains: ['Capital Allocation', 'RoRC'],
    riskType: 'Regulatory Capital',
    complexity: 'Configurable',
    outputTypes: ['Allocation Framework', 'Decision Dashboard Spec'],
    variables: [
      { name: 'business_units', type: 'textarea', default: 'Rates, Credit, Equities, FX, Prime Services' },
      { name: 'target_return_metric', type: 'text', default: 'RoRC > 15% through cycle' },
    ],
    prompt: `Design an internal capital allocation engine for {{business_units}}.
Target return metric: {{target_return_metric}}.

Provide allocation logic based on marginal capital usage,
stress performance, strategic priority, and diversification contribution.
Include governance for quarterly reallocation and exception handling.

Format: Allocation methodology with formulas, governance protocol, and reporting outputs.`,
  }),
  mk({
    id: 'C.10',
    title: 'Regulatory Audit Evidence Pack Generator Prompt',
    category: 'Regulatory & Capital',
    section: 'C.3 Audit and Compliance',
    roles: ['Compliance', 'Validator', 'Analyst'],
    domains: ['Audit', 'Evidence Management'],
    riskType: 'Regulatory Compliance',
    complexity: 'Quick Use',
    outputTypes: ['Evidence Index', 'Audit Pack'],
    variables: [
      { name: 'exam_scope', type: 'textarea', default: 'Market risk models, FRTB implementation controls, and model change governance' },
      { name: 'exam_date', type: 'date', default: '2026-09-15' },
    ],
    prompt: `Generate an examination evidence pack plan.
Scope: {{exam_scope}}.
Exam date: {{exam_date}}.

Build a complete evidence index with ownership,
traceability to control objectives, review checkpoints,
and response drafts for likely examiner questions.

Format: Audit-ready package outline with document-control workflow.`,
  }),
];

const quantPrompts = [
  mk({
    id: 'D.1',
    title: 'Correlation and Copula Analysis Framework',
    category: 'Quantitative Methods',
    section: 'D.1 Dependence Modeling',
    roles: ['Quant', 'Researcher', 'Validator'],
    domains: ['Correlation', 'Copulas', 'Tail Dependence'],
    riskType: 'Methodology',
    complexity: 'Deep Build',
    outputTypes: ['Research Paper', 'Implementation Pseudocode'],
    variables: [
      { name: 'asset_classes', type: 'multiselect', options: ['Rates', 'Credit', 'FX', 'Equities', 'Commodities'], default: ['Rates', 'Credit', 'FX'] },
      { name: 'known_issues', type: 'textarea', default: 'Correlation instability, nonlinear dependence, tail co-movement breakdown during crises' },
    ],
    prompt: `You are a senior quant analyzing the dependence structure across {{asset_classes}}
for the CIB risk framework.

The standard Pearson correlation matrix may be inadequate because:
{{known_issues}}

Build a comprehensive dependence analysis framework:

1. Correlation Estimation Methods:
   - Pearson (linear) correlation with confidence intervals
   - Spearman rank correlation (for nonlinear monotonic dependence)
   - Kendall's tau (more robust to outliers)
   - Dynamic Conditional Correlation (DCC-GARCH) for time-varying correlation
   - Realized correlation using intraday data
   - Stressed correlation estimation using crisis-period data
   - Shrinkage estimators (Ledoit-Wolf) for high-dimensional correlation matrices
   - Random matrix theory for noise filtering in large correlation matrices

2. Copula Selection and Fitting:
   Compare these copula families for our portfolio:
   - Gaussian copula: when it works, when it fails catastrophically (2008 lesson)
   - Student-t copula: tail dependence capture, degrees of freedom selection
   - Clayton copula: lower tail dependence (good for joint crashes)
   - Gumbel copula: upper tail dependence
   - Frank copula: symmetric, no tail dependence (benchmark)
   - Vine copulas (C-vine, D-vine, R-vine): for high-dimensional problems with
     heterogeneous pair dependencies
   For each: mathematical specification, estimation method (MLE, IFM, semi-parametric),
   goodness-of-fit tests, and computational complexity.

3. Tail Dependence Analysis:
   - Upper and lower tail dependence coefficients for each asset pair
   - Asymptotic vs. finite-sample tail dependence
   - Empirical tail dependence estimation using threshold exceedance methods
   - Implications for VaR and Expected Shortfall at extreme quantiles
   - How diversification benefits evaporate in the tails

4. Stress Correlation Scenarios:
   - Design 5 correlation stress scenarios relevant to {{asset_classes}}:
     a) Correlation convergence to 1 (flight to risk / risk-off)
     b) Correlation breakdown (previously correlated assets decouple)
     c) Cross-asset contagion (equity-credit-FX correlation spike)
     d) Regime-specific correlation shifts
     e) Sector-level correlation implosion

5. Implementation for VaR/Stress Testing:
   - How to embed the chosen copula model into our VaR simulation engine
   - Computational efficiency: how to simulate from high-dimensional copulas
   - Calibration frequency and recalibration triggers
   - How to stress correlations within the VaR framework without breaking positive-definiteness

Format: Technical research paper with mathematical derivations, simulation results
specifications, and implementation pseudocode.`,
  }),
  mk({
    id: 'D.2',
    title: 'Volatility Surface Construction and Dynamics',
    category: 'Quantitative Methods',
    section: 'D.2 Volatility Modeling',
    roles: ['Quant', 'Researcher'],
    domains: ['Vol Surface', 'Options Modeling'],
    riskType: 'Methodology',
    complexity: 'Deep Build',
    outputTypes: ['Modeling Handbook', 'Calibration Algorithms'],
    variables: [{ name: 'asset_class', type: 'select', options: ['Rates', 'FX', 'Equity', 'Commodity'], default: 'FX' }],
    prompt: `You are the head quant for the {{asset_class}} options desk responsible for
volatility surface construction and modeling.

Build the definitive volatility surface framework:

1. Surface Construction:
   - Raw data inputs: which instruments, tenors, strikes/deltas
   - Interpolation methodology across strike dimension:
     a) SVI (Stochastic Volatility Inspired) parameterization
     b) SABR model calibration
     c) Vanna-Volga method
     d) Non-parametric smoothing (kernel regression, cubic splines)
   - Interpolation across expiry dimension:
     a) Variance interpolation (total variance must be increasing)
     b) Calendar spread arbitrage elimination
   - No-arbitrage constraints enforcement:
     a) No butterfly arbitrage (positive probability density)
     b) No calendar spread arbitrage
     c) Lee's moment formula for wing behavior
   - Handling of sparse data points (illiquid strikes/expiries)

2. Surface Dynamics Models:
   For risk simulation, we need to model how the surface moves:
   - Sticky strike vs. sticky delta vs. sticky local vol
   - Stochastic volatility models: Heston, SABR, Bergomi
   - Local volatility (Dupire) and its limitations
   - Local-stochastic volatility (LSV) hybrid models
   - Jump-diffusion impact on surface dynamics
   - Principal Component Analysis of surface moves (typically 3-5 factors explain 95%+)
   - Regime-dependent surface dynamics

3. Surface Risk Metrics:
   - Vega by bucket (expiry  moneyness grid)
   - Weighted vega (adjusted for time-to-expiry)
   - Vanna and volga surfaces
   - Vol-of-vol sensitivity
   - Skew sensitivity (parallel shift vs. steepening/flattening)
   - Term structure sensitivity (level vs. slope vs. curvature)

4. Calibration and Validation:
   - Daily calibration procedure
   - Calibration quality metrics
   - Detecting calibration failures
   - Backtesting surface predictions against realized vol
   - Model risk assessment: impact of surface model choice on option valuations

Format: Quantitative modeling handbook with mathematical specifications,
calibration algorithms, and Python pseudocode for key computations.`,
  }),
  mk({
    id: 'D.3',
    title: 'Time Series Modeling for Risk Factors',
    category: 'Quantitative Methods',
    section: 'D.3 Time Series',
    roles: ['Quant', 'Researcher', 'Validator'],
    domains: ['Time Series', 'Volatility Forecasting'],
    riskType: 'Methodology',
    complexity: 'Deep Build',
    outputTypes: ['Technical Document', 'Empirical Template'],
    variables: [{ name: 'risk_factor_type', type: 'text', default: 'Cross-asset daily returns and implied volatility changes' }],
    prompt: `You are building the time series modeling framework for {{risk_factor_type}}
used in the CIB risk system.

Develop a comprehensive modeling approach:

1. Stylized Facts Analysis:
   Document the empirical properties of {{risk_factor_type}} that any model must capture:
   - Distribution shape (skewness, kurtosis, fat tails)
   - Volatility clustering and persistence (ARCH effects)
   - Mean reversion (or lack thereof)
   - Seasonality and day-of-week effects
   - Jump behavior and frequency
   - Long memory / fractional integration
   - Structural breaks and regime shifts
   - Cross-sectional dependence structure
   Provide specific statistical tests for each property.

2. Model Candidates:
   Compare these approaches for {{risk_factor_type}}:
   a) GARCH family: GARCH(1,1), EGARCH, GJR-GARCH, Component GARCH
   b) Stochastic volatility: discrete (SV) and continuous (Heston)
   c) Jump-diffusion: Merton, Kou, Bates
   d) Regime-switching: Markov-switching GARCH, Hamilton model
   e) Realized volatility models: HAR-RV, HEAVY
   f) Machine learning: LSTM for volatility forecasting, transformer architectures
   For each: mathematical specification, estimation method, forecasting performance
   metrics, and computational cost.

3. Model Selection Criteria:
   - In-sample fit vs. out-of-sample forecast accuracy trade-off
   - Specific loss functions: QLIKE, MSE, MAE for volatility forecasts
   - VaR and ES forecast accuracy (Kupiec, Christoffersen tests applied to model-based VaR)
   - Model Confidence Set (Hansen, Lunde and Nason) for statistical model comparison
   - Parsimony and interpretability considerations
   - Regulatory acceptability

4. Calibration and Monitoring:
   - Calibration frequency and methodology (MLE, Bayesian, method of moments)
   - Rolling vs. expanding window approaches
   - Parameter stability monitoring (control charts for model parameters)
   - Recalibration triggers
   - Model degradation detection (concept drift, structural break detection)

5. Integration with Risk Systems:
   - How the fitted model feeds into VaR, stress testing, and scenario generation
   - Simulation from the fitted model (path generation for Monte Carlo)
   - Ensuring consistency across risk factors (joint simulation requirements)
   - Computational optimization for production-scale implementation

Format: Research-grade technical document with equations, estimation algorithms,
Monte Carlo simulation specifications, and empirical analysis templates.`,
  }),
  mk({
    id: 'D.4',
    title: 'Bayesian Model Averaging for VaR Forecasting Prompt',
    category: 'Quantitative Methods',
    section: 'D.4 Advanced Estimation',
    roles: ['Quant', 'Researcher'],
    domains: ['Bayesian Methods', 'VaR'],
    riskType: 'Methodology',
    complexity: 'Deep Build',
    outputTypes: ['Method Design', 'Backtest Plan'],
    variables: [
      { name: 'candidate_models', type: 'textarea', default: 'HS, FHS, GARCH-parametric, EVT-tail, copula-MC' },
      { name: 'evaluation_horizon', type: 'select', options: ['1d', '10d'], default: '1d' },
    ],
    prompt: `Design a Bayesian model averaging framework for VaR forecasting.
Candidates: {{candidate_models}}.
Horizon: {{evaluation_horizon}}.

Specify priors, likelihood construction, posterior updating,
model probability smoothing, predictive interval construction,
and validation against single-model baselines.
Include governance controls for interpretability and production deployment.

Format: Full methodology note with equations and implementation roadmap.`,
  }),
  mk({
    id: 'D.5',
    title: 'Regime-Switching Scenario Generator Prompt',
    category: 'Quantitative Methods',
    section: 'D.4 Advanced Estimation',
    roles: ['Quant', 'Analyst'],
    domains: ['Regime Models', 'Scenario Generation'],
    riskType: 'Methodology',
    complexity: 'Configurable',
    outputTypes: ['Scenario Engine Spec'],
    variables: [
      { name: 'regime_labels', type: 'textarea', default: 'Low-vol carry, inflation shock, growth scare, liquidity freeze' },
      { name: 'transition_features', type: 'textarea', default: 'term premium, credit spread slope, vol-of-vol, macro surprises' },
    ],
    prompt: `Build a regime-switching scenario generator.
Regimes: {{regime_labels}}.
Transition drivers: {{transition_features}}.

Provide state definition, transition estimation,
regime-conditional distribution modeling,
scenario sampling logic, and validation against realized transitions.

Format: Quant specification with model equations and scenario output schema.`,
  }),
  mk({
    id: 'D.6',
    title: 'Extreme Value Theory Tail Calibration Prompt',
    category: 'Quantitative Methods',
    section: 'D.4 Advanced Estimation',
    roles: ['Quant', 'Validator'],
    domains: ['EVT', 'Tail Risk'],
    riskType: 'Methodology',
    complexity: 'Deep Build',
    outputTypes: ['Calibration Report'],
    variables: [
      { name: 'tail_side', type: 'select', options: ['Left tail', 'Right tail', 'Both tails'], default: 'Left tail' },
      { name: 'threshold_method', type: 'select', options: ['Mean Excess Plot', 'Stability Plot', 'Quantile Heuristic'], default: 'Stability Plot' },
    ],
    prompt: `Calibrate an EVT tail model for {{tail_side}} using {{threshold_method}}.

Deliver threshold selection rationale, GPD parameter estimation,
parameter uncertainty treatment, tail risk metric computation,
and backtesting of extreme quantile forecasts.

Format: Validation-ready EVT calibration report with sensitivity diagnostics.`,
  }),
  mk({
    id: 'D.7',
    title: 'High-Dimensional Factor Compression Prompt',
    category: 'Quantitative Methods',
    section: 'D.5 Numerical Methods',
    roles: ['Quant', 'Quant Developer'],
    domains: ['Dimension Reduction', 'Factor Models'],
    riskType: 'Methodology',
    complexity: 'Deep Build',
    outputTypes: ['Architecture Spec', 'Benchmark Plan'],
    variables: [
      { name: 'input_dimension', type: 'text', default: '320,000 risk factors' },
      { name: 'target_dimension', type: 'text', default: '450 latent factors' },
    ],
    prompt: `Design a high-dimensional factor compression framework.
Input dimension: {{input_dimension}}.
Target dimension: {{target_dimension}}.

Compare PCA variants, sparse methods, autoencoder-style reductions,
noise filtering, and interpretability constraints.
Define reconstruction-error tolerances and risk-metric preservation tests.

Format: Technical design with algorithm choices, compute profile, and validation benchmarks.`,
  }),
  mk({
    id: 'D.8',
    title: 'Monte Carlo Variance Reduction Blueprint Prompt',
    category: 'Quantitative Methods',
    section: 'D.5 Numerical Methods',
    roles: ['Quant', 'Quant Developer'],
    domains: ['Monte Carlo', 'Numerical Efficiency'],
    riskType: 'Methodology',
    complexity: 'Configurable',
    outputTypes: ['Optimization Blueprint'],
    variables: [
      { name: 'simulation_problem', type: 'textarea', default: '10-day ES with path-dependent rates and FX exotics under 150k factors' },
    ],
    prompt: `Create a variance reduction blueprint for {{simulation_problem}}.

Evaluate antithetic variates, control variates, stratification,
importance sampling, quasi-Monte Carlo, and multi-level Monte Carlo.
Quantify expected error vs runtime tradeoffs and propose deployment sequence.

Format: Implementation blueprint with acceptance criteria and benchmark methodology.`,
  }),
  mk({
    id: 'D.9',
    title: 'Model Risk Sensitivity Meta-Analysis Prompt',
    category: 'Quantitative Methods',
    section: 'D.6 Model Risk Analytics',
    roles: ['Validator', 'Quant'],
    domains: ['Model Risk', 'Sensitivity Analysis'],
    riskType: 'Model Risk',
    complexity: 'Configurable',
    outputTypes: ['Meta-Analysis Report'],
    variables: [
      { name: 'model_set', type: 'textarea', default: 'VaR engine, SVaR module, stress translator, XVA simulation, credit migration model' },
      { name: 'critical_outputs', type: 'textarea', default: 'Daily VaR, stressed loss, capital, CVA, ECL overlay' },
    ],
    prompt: `Perform a model risk sensitivity meta-analysis.
Model set: {{model_set}}.
Critical outputs: {{critical_outputs}}.

Create a cross-model framework to identify assumptions with highest enterprise impact,
including interaction effects, shared data dependencies, and correlated model failures.

Format: Enterprise model risk report with ranked sensitivity map and mitigation priorities.`,
  }),
  mk({
    id: 'D.10',
    title: 'Statistical Arbitrage Spillover Risk Detector Prompt',
    category: 'Quantitative Methods',
    section: 'D.6 Model Risk Analytics',
    roles: ['Quant', 'Analyst'],
    domains: ['Spillover Risk', 'Cross-Asset Dynamics'],
    riskType: 'Methodology',
    complexity: 'Configurable',
    outputTypes: ['Detection Framework'],
    variables: [
      { name: 'strategy_universe', type: 'textarea', default: 'Equity stat-arb, index basis, vol carry, cross-currency basis trades' },
    ],
    prompt: `Design a spillover risk detector for {{strategy_universe}}.

Specify indicators for crowding, common factor leverage,
liquidity shock amplification, and forced unwind contagion.
Provide alert thresholds and integration into daily risk governance.

Format: Detection framework with metrics, thresholds, and response playbooks.`,
  }),
];

const leadershipPrompts = [
  mk({
    id: 'E.1',
    title: 'CRO/Board Risk Report Generator',
    category: 'Senior Leadership & Governance',
    section: 'E.1 Executive Reporting',
    roles: ['Head of CIB Risk', 'Senior Leader'],
    domains: ['Executive Reporting', 'Governance'],
    riskType: 'Enterprise Risk',
    complexity: 'Configurable',
    outputTypes: ['Presentation Structure', 'Talking Points'],
    variables: [
      { name: 'report_frequency', type: 'select', options: ['Daily', 'Weekly', 'Monthly', 'Quarterly'], default: 'Monthly' },
      { name: 'audience', type: 'select', options: ['Board Risk Committee', 'CRO', 'Senior Risk Committee'], default: 'CRO' },
      { name: 'portfolio_metrics', type: 'textarea', default: 'VaR, ES, stress loss, concentration and utilization metrics' },
      { name: 'risk_events', type: 'textarea', default: 'Rate shock volatility spike, one VaR exception, two temporary limit excesses' },
      { name: 'model_risk_updates', type: 'textarea', default: 'One model moved to amber, two validations closed' },
      { name: 'regulatory_updates', type: 'textarea', default: 'FRTB implementation milestones on track; new exam requests received' },
      { name: 'limit_summary', type: 'textarea', default: '2 yellow desks, 0 red, improving trend' },
    ],
    prompt: `You are the Head of CIB Risk preparing the {{report_frequency}} risk report for
the {{audience}}.

Using the following inputs:
- Current portfolio metrics: {{portfolio_metrics}}
- Key risk events this period: {{risk_events}}
- Model risk updates: {{model_risk_updates}}
- Regulatory developments: {{regulatory_updates}}
- Limit utilization summary: {{limit_summary}}

Generate a comprehensive risk report structured for {{audience}}:

1. Executive Summary (1 page maximum):
   - Overall risk posture assessment (improving / stable / deteriorating) with 2-3 key reasons
   - Top 3 risks requiring senior management attention
   - Key decisions required from this audience
   - Regulatory or audit actions needed

2. Market Risk Overview:
   - VaR trends (current vs. limit vs. 12-month range), with attribution of major changes
   - Stress testing results: CCAR scenario P&L and year-over-year comparison
   - Significant position changes and their risk impact
   - VaR backtesting results and any model performance concerns
   - Emerging risks from current market environment

3. Credit and Counterparty Risk Overview:
   - Top counterparty exposures and changes
   - Credit quality migration trends (upgrades, downgrades, watchlist additions)
   - CVA P&L and hedging effectiveness
   - Any credit events or near-misses
   - Concentration risk assessment

4. Model Risk Update:
   - Model health portfolio summary (green/yellow/orange/red distribution)
   - Models requiring immediate attention (any red-status models)
   - Validation pipeline status
   - Open MRA/MRIA summary and aging analysis
   - New model approvals and model sunsets this period

5. Regulatory and Capital Update:
   - Capital utilization and trends
   - Regulatory examination status and findings
   - Upcoming regulatory changes and readiness assessment
   - CCAR/DFAST milestone status (during submission season)

6. Forward-Looking Risk Assessment:
   - Emerging risks on the horizon (geopolitical, market structure, technology)
   - Scenario analysis of current hot topics
   - Risk appetite utilization forecast
   - Strategic risk considerations for business decisions

Writing guidelines for {{audience}}:
{{#if audience == "Board Risk Committee"}}
- Non-technical language, focus on strategic implications
- Visual-heavy (charts, heat maps, trend arrows)
- Every metric needs context (what does this number mean for the business?)
- Clear decision points and recommendations
{{/if}}
{{#if audience == "CRO"}}
- Technical where needed, but lead with business impact
- Granular enough for follow-up questions
- Highlight items that need CRO escalation or decision
- Include comparison to risk appetite statements
{{/if}}
{{#if audience == "Senior Risk Committee"}}
- Full technical detail available but presented in digestible layers
- Drill-down structure: summary to detail to appendix
- Peer comparison where available
- Action items with owners and deadlines
{{/if}}

Format: Board-ready presentation structure with specific slide content,
chart specifications, and talking points for the presenter.`,
  }),
  mk({
    id: 'E.2',
    title: 'Risk Appetite Framework Design',
    category: 'Senior Leadership & Governance',
    section: 'E.2 Risk Appetite and Limits',
    roles: ['Head of CIB Risk', 'Senior Leader', 'Analyst'],
    domains: ['Risk Appetite', 'Limit Governance'],
    riskType: 'Enterprise Risk',
    complexity: 'Deep Build',
    outputTypes: ['Policy Framework', 'Limit Templates'],
    prompt: `You are designing the risk appetite framework for CIB, translating the
firm's board-level risk appetite statement into actionable metrics and limits
for the trading floor.

Build the complete cascade:

1. Board-Level Risk Appetite Statement to CIB-Level Risk Metrics:
   Map each board statement (e.g., \"We accept moderate market risk in pursuit of
   client-driven revenue\") to specific quantitative metrics:
   - Total VaR limit (99%, 1-day)
   - Stressed VaR limit
   - Total stress loss limit (per CCAR Severely Adverse scenario)
   - Revenue-at-Risk concentration limits
   - Expected Shortfall limits
   - Capital utilization target and hard limit

2. CIB-Level to Desk-Level Allocation:
   Methodology for allocating CIB limits to individual desks:
   - Historical P&L volatility contribution
   - Revenue generation and RoRC (Return on Risk Capital)
   - Strategic priority weighting
   - Diversification benefit allocation (who gets credit?)
   - Buffer/reserve for new business and limit flexibility
   - Dynamic reallocation triggers

3. Limit Structure Design:
   For each desk, define the complete limit hierarchy:
   - VaR limit (with sub-limits by risk type if needed)
   - Stress loss limits (multiple scenarios)
   - Sensitivity limits (DV01, CS01, Vega, etc.)
   - Concentration limits (single name, sector, country, tenor)
   - Notional/volume limits (for risk factors not well captured by Greeks)
   - Loss limits (daily stop-loss, cumulative MTD/YTD loss triggers)

4. Monitoring and Escalation Framework:
   - Green/Yellow/Red zones for each limit (e.g., Green <75%, Yellow 75-90%, Red 90-100%)
   - Daily monitoring report format
   - Breach notification protocol with escalation chain
   - Temporary limit excess (TLE) approval process and documentation
   - Automatic position reduction triggers (if any)

5. Annual Calibration Process:
   - How limits are recalibrated annually
   - Business planning integration
   - Stress testing feedback into limit setting
   - Board reporting on risk appetite utilization

Format: Policy framework document with quantitative examples, organizational
charts for escalation, and template limit reports.`,
  }),
  mk({
    id: 'E.3',
    title: 'Emerging Risk Radar and Horizon Scanning',
    category: 'Senior Leadership & Governance',
    section: 'E.3 Strategic Risk',
    roles: ['Head of CIB Risk', 'Senior Leader'],
    domains: ['Emerging Risk', 'Horizon Scan'],
    riskType: 'Enterprise Risk',
    complexity: 'Configurable',
    outputTypes: ['Risk Radar Data', 'Action Plan'],
    variables: [{ name: 'time_horizon', type: 'select', options: ['Quarterly', 'Semi-Annual', 'Annual'], default: 'Quarterly' }],
    prompt: `You are the Head of CIB Risk performing a {{time_horizon}} emerging risk assessment.

Conduct a systematic horizon scan across the following risk categories:

1. Geopolitical Risks:
   - Current geopolitical hotspots and their potential market impact
   - Scenario analysis for escalation/de-escalation of each
   - Specific transmission channels to CIB portfolio (sanctions, trade disruption,
     capital flow reversals, FX volatility)
   - Monitoring indicators and thresholds

2. Macroeconomic and Market Structure Risks:
   - Interest rate regime assessment (higher for longer? pivot risk? yield curve dynamics)
   - Inflation trajectory scenarios and impact on rates, credit, equities
   - Credit cycle positioning (are we late-cycle? stress indicators?)
   - Liquidity conditions (central bank balance sheet, repo market, basis trades)
   - Market microstructure risks (concentration in mega-cap tech, passive investing
     feedback loops, options market gamma effects)

3. Regulatory and Policy Risks:
   - Upcoming regulatory changes and implementation timelines
   - Potential new regulations on the horizon
   - Impact assessment for each on CIB capital, operations, and strategy
   - Compliance readiness gap analysis

4. Technology and Operational Risks:
   - AI/ML model risk in trading and risk systems
   - Cybersecurity threat landscape for financial institutions
   - Third-party/vendor concentration risks
   - Cloud migration risks and benefits
   - Quantum computing implications for cryptography and risk modeling

5. Climate and ESG Risks:
   - Physical risk scenarios for portfolio exposures
   - Transition risk scenarios (carbon pricing, stranded assets)
   - Regulatory expectations (climate stress testing)
   - Data and methodology gaps

For each identified risk:
- Probability assessment: Low / Medium / High
- Impact assessment: Low / Medium / High / Catastrophic
- Time horizon: Immediate / Near-term (0-6mo) / Medium-term (6-18mo) / Long-term (18mo+)
- Current monitoring status: Active / Passive / Not monitored
- Recommended action: Monitor / Prepare contingency / Hedge / De-risk

Format: Risk radar visualization data (for plotting on probability  impact matrix),
narrative assessments, and action plan for the top 5 risks.`,
  }),
  mk({
    id: 'E.4',
    title: 'Risk Committee Escalation Memo Composer Prompt',
    category: 'Senior Leadership & Governance',
    section: 'E.1 Executive Reporting',
    roles: ['Senior Leader', 'Head of CIB Risk'],
    domains: ['Escalation', 'Committee Governance'],
    riskType: 'Enterprise Risk',
    complexity: 'Quick Use',
    outputTypes: ['Escalation Memo'],
    variables: [
      { name: 'issue_summary', type: 'textarea', default: 'Three consecutive limit breaches in equity dispersion book with rising illiquidity' },
      { name: 'decision_needed', type: 'textarea', default: 'Temporary de-risk mandate and revised stop-loss thresholds' },
      { name: 'deadline', type: 'date', default: '2026-03-12' },
    ],
    prompt: `Draft an escalation memo for the Risk Committee.
Issue: {{issue_summary}}.
Decision required: {{decision_needed}}.
Decision deadline: {{deadline}}.

Structure memo with situation, quantified impact,
options considered, recommended path, and explicit decisions requested.

Format: One-page executive memo plus appendix requests for supporting analysis.`,
  }),
  mk({
    id: 'E.5',
    title: 'Desk Strategy vs Risk Appetite Review Prompt',
    category: 'Senior Leadership & Governance',
    section: 'E.2 Risk Appetite and Limits',
    roles: ['Senior Leader', 'Analyst'],
    domains: ['Strategy Review', 'Risk Appetite'],
    riskType: 'Enterprise Risk',
    complexity: 'Configurable',
    outputTypes: ['Review Deck'],
    variables: [
      { name: 'desk_strategy', type: 'textarea', default: 'Expand structured credit warehousing and increase flow options market share' },
      { name: 'appetite_constraints', type: 'textarea', default: 'Lower concentration tolerance and tighter stressed loss budget' },
    ],
    prompt: `Evaluate desk strategy alignment to risk appetite.
Strategy: {{desk_strategy}}.
Constraints: {{appetite_constraints}}.

Produce a gap analysis with quantified trade-offs,
required control enhancements, and approval conditions.

Format: Strategy review package with recommendation and monitoring KPIs.`,
  }),
  mk({
    id: 'E.6',
    title: 'Model Findings Closure Governance Review Prompt',
    category: 'Senior Leadership & Governance',
    section: 'E.2 Risk Appetite and Limits',
    roles: ['Senior Leader', 'Validator', 'Compliance'],
    domains: ['Model Governance', 'Findings Management'],
    riskType: 'Model Risk',
    complexity: 'Configurable',
    outputTypes: ['Closure Readout'],
    variables: [
      { name: 'open_findings', type: 'text', default: '27 open findings, including 4 high severity' },
      { name: 'aging_profile', type: 'textarea', default: 'Median age 146 days; 6 findings > 1 year' },
    ],
    prompt: `Prepare a governance review for model finding closure.
Open findings: {{open_findings}}.
Aging profile: {{aging_profile}}.

Provide root-cause clustering, closure blockers,
escalation proposals, and a realistic closure trajectory with owner commitments.

Format: Governance readout with risk implications and management actions.`,
  }),
  mk({
    id: 'E.7',
    title: 'Geopolitical War-Gaming Brief Builder Prompt',
    category: 'Senior Leadership & Governance',
    section: 'E.3 Strategic Risk',
    roles: ['Head of CIB Risk', 'Senior Leader'],
    domains: ['Geopolitics', 'War Gaming'],
    riskType: 'Enterprise Risk',
    complexity: 'Deep Build',
    outputTypes: ['War-Game Brief'],
    variables: [
      { name: 'hotspot_set', type: 'textarea', default: 'Taiwan Strait, Red Sea shipping, Eastern Europe energy corridor' },
      { name: 'portfolio_channels', type: 'textarea', default: 'Oil prices, shipping spreads, sovereign CDS, EMFX funding stress' },
    ],
    prompt: `Build a geopolitical war-gaming brief.
Hotspots: {{hotspot_set}}.
Transmission channels: {{portfolio_channels}}.

Design escalation pathways, market impact sequences,
contingency actions, and communication cadence for leadership.

Format: Scenario brief with trigger map, expected impact ranges, and action matrix.`,
  }),
  mk({
    id: 'E.8',
    title: 'Quarterly Risk Culture Assessment Prompt',
    category: 'Senior Leadership & Governance',
    section: 'E.4 Culture and Conduct',
    roles: ['Head of CIB Risk', 'Senior Leader', 'Compliance'],
    domains: ['Risk Culture', 'Conduct Risk'],
    riskType: 'Governance Risk',
    complexity: 'Quick Use',
    outputTypes: ['Assessment Report'],
    variables: [
      { name: 'assessment_inputs', type: 'textarea', default: 'Limit override frequency, escalation quality, near-miss reporting, control attestation results' },
    ],
    prompt: `Conduct a quarterly risk culture assessment using:
{{assessment_inputs}}.

Produce an evidence-based evaluation of tone, behavior,
control adherence, and challenge effectiveness across trading and risk functions.
Include targeted interventions and measurable follow-up indicators.

Format: Board-level culture assessment with heatmap and action plan.`,
  }),
];

const dataTechPrompts = [
  mk({
    id: 'F.1',
    title: 'Market Data Quality Framework',
    category: 'Data & Technology',
    section: 'F.1 Data Quality',
    roles: ['Data Engineer', 'Quant Developer', 'Analyst'],
    domains: ['Market Data', 'Data Quality'],
    riskType: 'Operational Risk',
    complexity: 'Deep Build',
    outputTypes: ['Technical Spec', 'Rules Engine'],
    variables: [
      { name: 'number_of_risk_drivers', type: 'slider', min: 50000, max: 500000, step: 5000, default: 300000 },
      { name: 'data_sources', type: 'textarea', default: 'Bloomberg B-PIPE, Refinitiv, internal curves service, broker contributors' },
    ],
    prompt: `You are building the market data quality monitoring framework for the CIB Risk
infrastructure, covering {{number_of_risk_drivers}} risk drivers sourced from
{{data_sources}}.

Design the complete DQ framework:

1. Data Quality Dimensions and Metrics:
   For each dimension, define specific measurable metrics:
   a) Completeness: percent of expected data points received, gap analysis
   b) Timeliness: delivery time vs. SLA, staleness detection
   c) Accuracy: deviation from alternative sources, outlier detection
   d) Consistency: cross-source reconciliation, internal consistency checks
   e) Validity: range checks, sign checks, business rule validation
   f) Uniqueness: duplicate detection

2. Automated Quality Checks by Data Type:
   - Price data: stale price detection, price jump detection (Z-score),
     bid-ask spread reasonableness, negative price alerts
   - Yield curves: monotonicity checks, smoothness tests, cross-currency consistency
   - Volatility surfaces: no-arbitrage checks (butterfly, calendar spread),
     smoothness, extreme smile detection
   - Credit spreads: rating-ordering consistency, sector-relative checks,
     curve inversion alerts
   - Reference data: entity matching accuracy, corporate action processing

3. Anomaly Detection Engine:
   - Statistical methods: Z-score, modified Z-score (MAD-based), Grubbs' test
   - Time series methods: ARIMA residual analysis, change point detection
   - Machine learning methods: Isolation Forest, DBSCAN, autoencoders
   - Context-aware detection (what looks anomalous in calm markets is normal in crisis)
   - False positive reduction strategies

4. Remediation Workflows:
   - Automated vs. manual remediation decision tree
   - Fallback/proxy hierarchy when primary data is unavailable
   - Stale data escalation: after X hours, auto-switch to proxy; after Y hours, halt model run
   - Impact assessment: which models and reports are affected by each data issue?

5. Reporting and Governance:
   - Daily data quality scorecard
   - Data quality SLA definitions by data criticality tier
   - Vendor performance tracking
   - Root cause analysis for recurring issues
   - Data quality improvement roadmap

Format: Technical specification with monitoring rules engine design,
alert configuration templates, and dashboard wireframes.`,
  }),
  mk({
    id: 'F.2',
    title: 'Python Risk Analytics Code Generator',
    category: 'Data & Technology',
    section: 'F.2 Engineering Productivity',
    roles: ['Quant Developer', 'Quant', 'Data Engineer'],
    domains: ['Python', 'Risk Analytics'],
    riskType: 'Technology',
    complexity: 'Configurable',
    outputTypes: ['Python Module', 'Unit Tests'],
    variables: [
      {
        name: 'analytics_task',
        type: 'select',
        options: [
          'Historical Simulation VaR Calculator',
          'Monte Carlo VaR with Copulas',
          'GARCH(1,1) Volatility Forecaster',
          'DCC Correlation Estimator',
          'PCA-Based Yield Curve Decomposition',
          'VaR Backtesting Suite',
          'Stress Scenario P&L Calculator',
          'Risk Factor Hierarchy Shock Propagator',
          'Expected Shortfall Calculator',
          'P&L Attribution Engine',
          'Correlation Matrix Stress Tester',
          'Population Stability Index Monitor',
          'SABR Calibration',
          'Credit Transition Matrix Estimator',
          'SA-CCR Exposure Calculator',
          'CVA Calculator',
          'Limit Monitoring Engine',
          'Time Series Anomaly Detector',
          'Monte Carlo Simulation Engine',
          'Risk Report Data Aggregator',
        ],
        default: 'VaR Backtesting Suite',
      },
      { name: 'data_scale', type: 'text', default: '25 million rows' },
      { name: 'task_description', type: 'textarea', default: 'Implement daily batch computation plus intraday incremental update support.' },
    ],
    prompt: `You are a senior Python developer on the CIB Risk quantitative analytics team.

Generate production-quality Python code for {{analytics_task}}.

Requirements:
- Language: Python 3.10+
- Key libraries: numpy, pandas, scipy, statsmodels, arch, matplotlib, plotly
- Code must be production-grade: type hints, docstrings, error handling, logging
- Modular design with clear separation of concerns
- Unit tests included
- Performance-optimized for {{data_scale}} data points

Specific task: {{task_description}}

Output structure:
1. Module/class design overview
2. Complete implementation code with comprehensive docstrings
3. Usage examples with sample data
4. Unit test suite
5. Performance benchmarks and optimization notes
6. Known limitations and edge cases

Code quality standards:
- PEP 8 compliant
- Numpy-style docstrings
- Type hints on all function signatures
- Defensive programming: validate inputs, handle edge cases gracefully
- No magic numbers - all constants named and documented
- Vectorized operations where possible (avoid Python loops over large arrays)`,
  }),
  mk({
    id: 'F.3',
    title: 'SQL Query Library for Risk Data',
    category: 'Data & Technology',
    section: 'F.2 Engineering Productivity',
    roles: ['Data Engineer', 'Analyst', 'Quant Developer'],
    domains: ['SQL', 'Risk Data'],
    riskType: 'Technology',
    complexity: 'Configurable',
    outputTypes: ['SQL Query', 'Optimization Notes'],
    variables: [
      { name: 'sql_dialect', type: 'select', options: ['PostgreSQL', 'Snowflake', 'BigQuery', 'SQL Server'], default: 'PostgreSQL' },
      { name: 'query_description', type: 'textarea', default: 'Top-20 desks by stressed loss vs limit with trend and data quality flags' },
    ],
    prompt: `You are a data engineer supporting the CIB Risk analytics team.

Generate an optimized SQL query ({{sql_dialect}}) for:

{{query_description}}

The data model includes these key tables:
- positions: trade_id, desk, book, product_type, notional, currency, counterparty_id,
  trade_date, maturity_date, last_updated
- risk_sensitivities: trade_id, risk_factor_id, sensitivity_type (delta, gamma, vega, etc.),
  sensitivity_value, as_of_date
- market_data: risk_factor_id, data_source, value, as_of_date, snap_time
- var_results: desk, var_type (HS, MC, Parametric), confidence_level, horizon,
  var_amount, as_of_date
- pnl_data: desk, book, pnl_type (actual, hypothetical, risk_theoretical),
  pnl_amount, as_of_date
- counterparties: counterparty_id, name, rating, sector, country, cds_spread, pfe_limit
- model_inventory: model_id, model_name, risk_type, health_score, last_validation_date,
  open_findings_count

Requirements:
- Optimized for performance (appropriate indexing hints, CTEs vs. subqueries)
- Include comments explaining logic
- Handle edge cases (nulls, weekends/holidays, missing data)
- Parameterized where appropriate
- Include execution plan analysis recommendations

Format: Complete SQL with comments, expected output schema, and optimization notes.`,
  }),
  mk({
    id: 'F.4',
    title: 'Data Lineage and Control Mapping Generator Prompt',
    category: 'Data & Technology',
    section: 'F.1 Data Quality',
    roles: ['Data Engineer', 'Compliance'],
    domains: ['Data Lineage', 'Controls'],
    riskType: 'Operational Risk',
    complexity: 'Configurable',
    outputTypes: ['Lineage Map', 'Control Matrix'],
    variables: [
      { name: 'critical_reports', type: 'textarea', default: 'Daily VaR report, weekly stress report, monthly capital pack' },
      { name: 'source_systems', type: 'textarea', default: 'Trade capture, market data hub, risk calc grid, reporting mart' },
    ],
    prompt: `Build a lineage and control mapping for critical risk reporting.
Reports: {{critical_reports}}.
Source systems: {{source_systems}}.

Produce source-to-report lineage, transformation controls,
reconciliation checkpoints, failure impacts, and ownership matrix.

Format: Audit-ready lineage and controls documentation.`,
  }),
  mk({
    id: 'F.5',
    title: 'Real-Time Risk API Contract Designer Prompt',
    category: 'Data & Technology',
    section: 'F.3 Architecture',
    roles: ['Data Engineer', 'Quant Developer'],
    domains: ['APIs', 'Real-Time Risk'],
    riskType: 'Technology',
    complexity: 'Configurable',
    outputTypes: ['API Spec'],
    variables: [
      { name: 'consumers', type: 'textarea', default: 'Desk risk UI, central risk dashboard, alerting engine, model monitoring service' },
      { name: 'latency_target', type: 'text', default: '< 2 seconds p95' },
    ],
    prompt: `Design a real-time risk API contract.
Consumers: {{consumers}}.
Latency target: {{latency_target}}.

Specify endpoints, schemas, pagination/streaming strategy,
idempotency, versioning, data quality flags, and access controls.

Format: Production API specification with SLA and failure-mode behavior.`,
  }),
  mk({
    id: 'F.6',
    title: 'Batch-to-Streaming Migration Plan for Risk Platform Prompt',
    category: 'Data & Technology',
    section: 'F.3 Architecture',
    roles: ['Data Engineer', 'Senior Leader', 'Quant Developer'],
    domains: ['Platform Migration', 'Streaming'],
    riskType: 'Technology',
    complexity: 'Deep Build',
    outputTypes: ['Migration Plan'],
    variables: [
      { name: 'current_batch_scope', type: 'textarea', default: 'End-of-day VaR, stress, and limits computation on overnight grid' },
      { name: 'target_streaming_scope', type: 'textarea', default: 'Intraday sensitivity refresh, near-real-time stress and limit utilization' },
    ],
    prompt: `Create a migration plan from batch to streaming risk analytics.
Current scope: {{current_batch_scope}}.
Target scope: {{target_streaming_scope}}.

Define phased architecture, dual-run controls,
data consistency guarantees, rollback strategy,
and governance checkpoints.

Format: Program plan with architecture states, risks, and acceptance criteria.`,
  }),
  mk({
    id: 'F.7',
    title: 'Prompt Telemetry and Effectiveness Analytics Spec',
    category: 'Data & Technology',
    section: 'F.4 AI Tooling',
    roles: ['Data Engineer', 'Senior Leader', 'Analyst'],
    domains: ['Prompt Analytics', 'Product Telemetry'],
    riskType: 'Technology',
    complexity: 'Quick Use',
    outputTypes: ['Telemetry Spec'],
    variables: [
      { name: 'adoption_goal', type: 'text', default: 'Increase high-quality prompt reuse by 40% in 2 quarters' },
    ],
    prompt: `Design telemetry and analytics for the risk prompt suite.
Adoption goal: {{adoption_goal}}.

Define event taxonomy, data model, quality metrics,
privacy controls, dashboard KPIs, and experimentation framework for prompt improvement.

Format: Product analytics specification with instrumentation plan.`,
  }),
  mk({
    id: 'F.8',
    title: 'Infrastructure Resilience Chaos Test Planner Prompt',
    category: 'Data & Technology',
    section: 'F.3 Architecture',
    roles: ['Data Engineer', 'Quant Developer', 'Senior Leader'],
    domains: ['Resilience', 'Chaos Engineering'],
    riskType: 'Operational Risk',
    complexity: 'Configurable',
    outputTypes: ['Chaos Test Plan'],
    variables: [
      { name: 'critical_services', type: 'textarea', default: 'Market data ingestion, calc grid scheduler, scenario store, risk API gateway' },
      { name: 'recovery_targets', type: 'text', default: 'RTO 30 minutes, RPO 5 minutes for critical services' },
    ],
    prompt: `Build a chaos testing plan for risk infrastructure.
Critical services: {{critical_services}}.
Recovery targets: {{recovery_targets}}.

Specify failure injections, blast radius controls,
success criteria, observability requirements,
and remediation workflow for uncovered weaknesses.

Format: Operational test plan with governance and production safety guards.`,
  }),
];

const workflowPrompts = [
  mk({
    id: 'G.1',
    title: 'End-to-End New Model Validation Workflow',
    category: 'Workflows & Chains',
    section: 'G.1 Validation Chains',
    roles: ['Validator', 'Quant', 'Analyst'],
    domains: ['Workflow', 'Model Validation'],
    riskType: 'Model Risk',
    complexity: 'Deep Build',
    outputTypes: ['Prompt Chain'],
    complianceTag: 'Regulatory Submission Ready',
    prompt: `This is a 5-step prompt chain for conducting a complete model validation.
Execute each step in sequence, using the output of each step as input to the next.

STEP 1 - CONCEPTUAL SOUNDNESS REVIEW:
[Full prompt for reviewing theoretical basis, methodology selection,
assumptions, mathematical derivations, and limitations]

STEP 2 - DATA AND INPUT ANALYSIS:
[Full prompt for assessing data quality, representativeness, feature
engineering, sample construction, and data lineage]

STEP 3 - OUTCOMES ANALYSIS (QUANTITATIVE TESTING):
[Full prompt for backtesting, benchmarking, sensitivity analysis,
stability testing, and challenger model comparison]

STEP 4 - FINDING FORMULATION:
[Full prompt for categorizing issues found in Steps 1-3 into MRAs/MRIAs
with severity, impact assessment, and remediation recommendations]

STEP 5 - VALIDATION REPORT DRAFTING:
[Full prompt for assembling findings into a formal validation report
per SR 11-7 standards with executive summary, detailed findings,
overall model adequacy determination, and conditions of use]`,
  }),
  mk({
    id: 'G.2',
    title: 'Daily Risk Morning Meeting Prep',
    category: 'Workflows & Chains',
    section: 'G.2 Daily Operations',
    roles: ['Analyst', 'Senior Leader', 'Head of CIB Risk'],
    domains: ['Workflow', 'Daily Risk Operations'],
    riskType: 'Enterprise Risk',
    complexity: 'Quick Use',
    outputTypes: ['Briefing'],
    variables: [
      { name: 'yesterdays_pnl', type: 'text', default: '-USD 28mm' },
      { name: 'var_utilization', type: 'text', default: '82% aggregate; 2 desks > 90%' },
      { name: 'var_exceptions', type: 'text', default: '1 exception in EM credit' },
      { name: 'market_moves', type: 'textarea', default: 'UST +14bps bear flattening, IG +12bps, SPX -1.8%, USDJPY -1.2%' },
      { name: 'limit_breaches', type: 'text', default: 'One temporary excess in FX options vega' },
      { name: 'counterparty_alerts', type: 'text', default: 'Two counterparties with CDS widening > 3 sigma' },
      { name: 'system_issues', type: 'text', default: 'Minor lag in commodity vols feed fixed at 06:10' },
      { name: 'aum', type: 'text', default: '1.9T' },
    ],
    prompt: `You are preparing the daily morning risk briefing for the CIB Risk
leadership meeting at 7:30 AM.

Using the following overnight data:
- Yesterday's P&L: {{yesterdays_pnl}}
- VaR utilization: {{var_utilization}}
- VaR exceptions: {{var_exceptions}}
- Notable market moves: {{market_moves}}
- Limit breaches: {{limit_breaches}}
- Counterparty alerts: {{counterparty_alerts}}
- Model/system issues: {{system_issues}}

Generate a structured 5-minute morning briefing:

1. P&L Flash (30 seconds):
   - Desk-level P&L, highlight top 3 movers
   - Actual vs. VaR comparison
   - Any VaR exceptions with immediate root cause hypothesis

2. Market Overnight (60 seconds):
   - Key moves across asset classes
   - What drove the moves (economic data, geopolitical, technicals)
   - Implied vol and correlation changes
   - Today's upcoming events/data releases that matter

3. Risk Alerts (60 seconds):
   - Any limit breaches and current status
   - Counterparty credit alerts
   - Data/model/system issues affecting risk numbers
   - Actions required and owners

4. Forward Look (30 seconds):
   - Today's key risk events (central bank decisions, earnings, data releases)
   - Positions to watch
   - Any stress scenario updates needed

5. Action Items (30 seconds):
   - Clear action items with owners and deadlines
   - Escalation items for senior management

Tone: Crisp, direct, no filler. These people are running {{aum}} in risk capital.
Every word must earn its place in the briefing.`,
  }),
  mk({
    id: 'G.3',
    title: 'Weekly Limit Breach Investigation Chain',
    category: 'Workflows & Chains',
    section: 'G.2 Daily Operations',
    roles: ['Analyst', 'Validator', 'Senior Leader'],
    domains: ['Workflow', 'Limit Governance'],
    riskType: 'Market Risk',
    complexity: 'Configurable',
    outputTypes: ['Prompt Chain', 'Investigation Report'],
    variables: [
      { name: 'breach_log', type: 'textarea', default: '3 sensitivity breaches, 1 stress-loss breach, all resolved within T+1' },
    ],
    prompt: `Run a weekly 4-step limit breach investigation chain.
Input breach log: {{breach_log}}.

Step 1: Data integrity and false-positive screening.
Step 2: Position/risk-factor decomposition and root-cause ranking.
Step 3: Control assessment and policy adherence review.
Step 4: Management report with remediation and deadline tracking.

Format: Standardized workflow outputs suitable for governance archive.`,
  }),
  mk({
    id: 'G.4',
    title: 'Monthly Model Monitoring Chain',
    category: 'Workflows & Chains',
    section: 'G.1 Validation Chains',
    roles: ['Validator', 'Analyst'],
    domains: ['Workflow', 'Model Monitoring'],
    riskType: 'Model Risk',
    complexity: 'Configurable',
    outputTypes: ['Monitoring Chain', 'Model Health Summary'],
    variables: [
      { name: 'model_inventory_slice', type: 'textarea', default: 'Top 25 market and credit risk models by materiality tier' },
    ],
    prompt: `Execute a monthly model monitoring chain for {{model_inventory_slice}}.

Step sequence:
1. Data freshness and KPI completeness checks.
2. Performance drift diagnostics and threshold tests.
3. Control effectiveness and override review.
4. Findings classification and owner assignments.
5. Executive summary generation for Model Risk Committee.

Format: Chain-ready outputs with traceable evidence references.`,
  }),
  mk({
    id: 'G.5',
    title: 'CCAR Translation to Board Narrative Chain',
    category: 'Workflows & Chains',
    section: 'G.3 Stress Program Chains',
    roles: ['Senior Leader', 'Analyst', 'Head of CIB Risk'],
    domains: ['Workflow', 'CCAR', 'Executive Narrative'],
    riskType: 'Regulatory Capital',
    complexity: 'Deep Build',
    outputTypes: ['Prompt Chain', 'Board Narrative'],
    variables: [
      { name: 'scenario_package', type: 'textarea', default: 'Fed severely adverse macro path + internally expanded market factor translation' },
    ],
    prompt: `Run a 5-step chain from technical CCAR translation to board-ready narrative.
Scenario package: {{scenario_package}}.

Step 1: Technical shock translation validation.
Step 2: Desk-level stressed P&L attribution.
Step 3: Capital impact and management action assessment.
Step 4: Challenge synthesis across first/second line.
Step 5: Board narrative with decision points and risk posture conclusion.

Format: End-to-end chain with artifacts suitable for board distribution and regulator traceability.`,
  }),
  mk({
    id: 'G.6',
    title: 'New Product Approval Risk Chain',
    category: 'Workflows & Chains',
    section: 'G.4 New Business',
    roles: ['Analyst', 'Validator', 'Compliance', 'Senior Leader'],
    domains: ['Workflow', 'New Product Governance'],
    riskType: 'Enterprise Risk',
    complexity: 'Configurable',
    outputTypes: ['Approval Workflow'],
    variables: [
      { name: 'new_product', type: 'text', default: 'Callable ESG-linked cross-currency note' },
    ],
    prompt: `Create a full approval chain for {{new_product}}.

Steps:
1. Product payoff and model risk decomposition.
2. Market, credit, liquidity, and operational risk assessment.
3. Valuation control and data availability checks.
4. Limit proposal and monitoring design.
5. Governance sign-off packet with conditions precedent.

Format: Workflow pack with structured step outputs and approval gates.`,
  }),
  mk({
    id: 'G.7',
    title: 'Incident to Remediation Workflow Chain',
    category: 'Workflows & Chains',
    section: 'G.2 Daily Operations',
    roles: ['Analyst', 'Data Engineer', 'Senior Leader'],
    domains: ['Workflow', 'Incident Management'],
    riskType: 'Operational Risk',
    complexity: 'Quick Use',
    outputTypes: ['Incident Workflow'],
    variables: [
      { name: 'incident_type', type: 'text', default: 'Market data outage impacting rates vol surface for 42 minutes' },
    ],
    prompt: `Run an incident-to-remediation chain for: {{incident_type}}.

Step 1: Incident triage and blast radius quantification.
Step 2: Temporary controls and business communication.
Step 3: Root cause and permanent fix plan.
Step 4: Control enhancement and testing evidence.
Step 5: Closure memo with lessons learned.

Format: Operational chain with timestamps, owners, and closure criteria.`,
  }),
];

const aiMetaPrompts = [
  mk({
    id: 'H.1',
    title: 'AI Model Risk Assessment for ML in Production',
    category: 'AI/Meta',
    section: 'H.1 AI Model Governance',
    roles: ['Validator', 'Quant', 'Compliance'],
    domains: ['AI Model Risk', 'ML Validation'],
    riskType: 'Model Risk',
    complexity: 'Deep Build',
    regulatory: ['SR 11-7'],
    outputTypes: ['Validation Report'],
    variables: [
      { name: 'ml_model_type', type: 'text', default: 'Gradient-boosted trees with monotonic constraints' },
      { name: 'use_case', type: 'text', default: 'Intraday liquidity stress warning score' },
    ],
    prompt: `You are the model validator assessing the risk of deploying a {{ml_model_type}}
machine learning model for {{use_case}} in the CIB risk framework.

This is a specialized model validation because ML models present unique risks
not covered by traditional SR 11-7 frameworks.

Conduct a comprehensive ML Model Risk Assessment:

1. Conceptual Soundness for ML:
   - Is ML appropriate for this use case vs. traditional statistical methods?
   - Interpretability assessment: can we explain individual predictions?
   - Feature importance analysis: SHAP values, permutation importance
   - Are the learned relationships economically intuitive?
   - Does the model capture known domain relationships (monotonicity, bounds)?

2. Data Risk Assessment:
   - Training data representativeness across market regimes
   - Label quality and consistency
   - Feature leakage detection
   - Distribution shift between training and production data
   - Bias detection across relevant segments

3. Performance and Robustness:
   - Out-of-sample performance across multiple time periods
   - Performance under stress periods specifically
   - Adversarial robustness: small input perturbation to large output change?
   - Extrapolation behavior: what happens outside training data range?
   - Comparison to interpretable benchmark model (logistic regression, linear model)

4. Operational Risk:
   - Model monitoring in production: what metrics, what thresholds?
   - Drift detection: input drift, concept drift, prediction drift
   - Fallback strategy if model performance degrades
   - Model update/retraining governance
   - Reproducibility: can we reproduce training results?

5. Regulatory Considerations:
   - SR 11-7 compliance with ML-specific interpretations
   - Explainability requirements for regulatory submissions
   - Documentation standards for ML models (higher bar than traditional)
   - Regulatory examination preparedness

6. Recommendation:
   - Approve / Approve with conditions / Reject
   - If approved: specific ongoing monitoring requirements
   - If rejected: specific improvements needed before re-submission
   - Compensating controls if approved with limitations

Format: ML Model Validation Report with findings classified by severity
and specific, actionable remediation recommendations.`,
  }),
  mk({
    id: 'H.2',
    title: 'Custom Prompt Engineering for Risk Analysts',
    category: 'AI/Meta',
    section: 'H.2 Prompt Crafting',
    roles: ['Analyst', 'Quant', 'Senior Leader'],
    domains: ['Prompt Engineering', 'AI Enablement'],
    riskType: 'Productivity',
    complexity: 'Configurable',
    outputTypes: ['Prompt Guide', 'Cheat Sheet'],
    variables: [
      { name: 'analyst_task', type: 'textarea', default: 'Build a desk-level stress narrative from daily risk numbers and market context' },
    ],
    prompt: `You are training CIB Risk analysts to write effective AI prompts for
their specific domain.

Given that the analyst wants to use AI for: {{analyst_task}}

Build a customized prompt engineering guide:

1. Task Decomposition:
   Break {{analyst_task}} into discrete sub-tasks that AI can handle well:
   - Which sub-tasks benefit most from AI assistance?
   - Which sub-tasks require human judgment and should NOT be delegated?
   - Optimal human-AI collaboration workflow

2. Prompt Template:
   Write a specific, ready-to-use prompt template for {{analyst_task}} including:
   - Context setting (role, domain, constraints)
   - Task specification (be precise about what output is needed)
   - Input data format (how to structure data for the AI)
   - Output format specification (tables, code, narratives, LaTeX)
   - Quality constraints (accuracy requirements, regulatory standards)
   - Example input/output pair for few-shot learning

3. Common Pitfalls:
   - Prompts that sound right but produce poor results for {{analyst_task}}
   - How to detect when AI output is confidently wrong (hallucination risks)
   - Domain-specific validation checks to apply to AI output
   - When to iterate on the prompt vs. when to do it manually

4. Iteration Strategy:
   - How to refine the prompt based on initial output quality
   - A/B testing approach for prompt variants
   - Building a personal prompt library over time

Format: Practical guide with templates, examples, and a quick-reference cheat sheet.`,
  }),
  mk({
    id: 'H.3',
    title: 'Prompt Hallucination Control Framework',
    category: 'AI/Meta',
    section: 'H.1 AI Model Governance',
    roles: ['Validator', 'Analyst', 'Compliance'],
    domains: ['AI Quality Control', 'Hallucination Risk'],
    riskType: 'Model Risk',
    complexity: 'Configurable',
    outputTypes: ['Control Framework'],
    variables: [
      { name: 'prompt_domain', type: 'text', default: 'Regulatory capital analysis and reporting' },
    ],
    prompt: `Design a hallucination control framework for AI prompts in {{prompt_domain}}.

Include pre-prompt guardrails, source grounding requirements,
numeric sanity checks, mandatory uncertainty signaling,
and human validation checkpoints by materiality tier.

Format: Practical control framework with checklists and escalation criteria.`,
  }),
  mk({
    id: 'H.4',
    title: 'Agentic Workflow Safety Guardrail Prompt',
    category: 'AI/Meta',
    section: 'H.1 AI Model Governance',
    roles: ['Compliance', 'Data Engineer', 'Senior Leader'],
    domains: ['Agentic AI', 'Safety Controls'],
    riskType: 'Operational Risk',
    complexity: 'Configurable',
    outputTypes: ['Safety Policy', 'Control Design'],
    variables: [
      { name: 'agent_scope', type: 'textarea', default: 'Automated generation of daily risk commentary and draft escalation memos' },
    ],
    prompt: `Create a safety guardrail design for an agentic workflow.
Scope: {{agent_scope}}.

Specify allowed actions, prohibited actions,
approval gates, audit logging, rollback behavior,
and periodic assurance tests.

Format: Control policy and implementation checklist for safe production rollout.`,
  }),
];

const liquidityPrompts = [
  mk({
    id: 'L.1',
    title: 'Intraday Liquidity Stress Ladder Prompt',
    category: 'Liquidity Risk',
    section: 'L.1 Liquidity Stress',
    roles: ['Analyst', 'Senior Leader'],
    domains: ['Liquidity Risk', 'Stress Testing'],
    riskType: 'Liquidity Risk',
    complexity: 'Deep Build',
    outputTypes: ['Stress Ladder', 'Action Plan'],
    variables: [
      { name: 'liquidity_buffer', type: 'text', default: 'USD 42bn HQLA and pre-positioned collateral' },
      { name: 'intraday_outflow_drivers', type: 'textarea', default: 'CCP margin calls, bilateral collateral calls, unsecured funding roll-off, client drawdowns' },
    ],
    prompt: `Design an intraday liquidity stress ladder.
Current buffer: {{liquidity_buffer}}.
Outflow drivers: {{intraday_outflow_drivers}}.

Construct escalating stress states with 30-minute granularity,
funding source availability assumptions, collateral mobilization constraints,
and trigger-based management actions.

Format: Treasury-risk integrated stress ladder with thresholds, owners, and contingency actions.`,
  }),
  mk({
    id: 'L.2',
    title: 'Funding Concentration and Contingency Plan Prompt',
    category: 'Liquidity Risk',
    section: 'L.2 Funding Risk',
    roles: ['Senior Leader', 'Analyst'],
    domains: ['Funding Risk', 'Contingency Planning'],
    riskType: 'Liquidity Risk',
    complexity: 'Configurable',
    outputTypes: ['Contingency Plan'],
    variables: [
      { name: 'funding_profile', type: 'textarea', default: '42% short-term wholesale, 28% secured, 30% stable internal transfer pricing sources' },
      { name: 'concentration_hotspots', type: 'textarea', default: 'Two prime funds and one tri-party channel exceed concentration thresholds' },
    ],
    prompt: `Create a funding concentration risk assessment and contingency plan.
Funding profile: {{funding_profile}}.
Hotspots: {{concentration_hotspots}}.

Deliver concentration diagnostics,
stress rollover assumptions, fallback funding hierarchy,
and execution playbooks with governance triggers.

Format: Actionable funding contingency document with timeline and capacity assumptions.`,
  }),
  mk({
    id: 'L.3',
    title: 'LCR/NSFR Early Warning Diagnostics Prompt',
    category: 'Liquidity Risk',
    section: 'L.3 Regulatory Liquidity',
    roles: ['Analyst', 'Compliance', 'Senior Leader'],
    domains: ['LCR', 'NSFR', 'Early Warning'],
    riskType: 'Liquidity Risk',
    complexity: 'Configurable',
    regulatory: ['Basel Liquidity'],
    complianceTag: 'Regulatory Submission Ready',
    outputTypes: ['Diagnostics Report'],
    variables: [
      { name: 'current_lcr', type: 'text', default: '121%' },
      { name: 'current_nsfr', type: 'text', default: '108%' },
      { name: 'stress_assumptions', type: 'textarea', default: 'Deposit outflow +12%, secured funding haircut +8%, HQLA monetization lag +1 day' },
    ],
    prompt: `Build an early warning diagnostic framework for LCR/NSFR.
Current LCR: {{current_lcr}}.
Current NSFR: {{current_nsfr}}.
Stress assumptions: {{stress_assumptions}}.

Provide forward indicators, threshold logic,
scenario-conditioned trajectories, and pre-emptive management actions.

Format: Regulatory liquidity diagnostic with monitoring dashboard requirements.`,
  }),
];

const allPrompts = [
  ...marketPrompts,
  ...creditPrompts,
  ...regulatoryPrompts,
  ...quantPrompts,
  ...leadershipPrompts,
  ...dataTechPrompts,
  ...workflowPrompts,
  ...aiMetaPrompts,
  ...liquidityPrompts,
];

const categoryOrder = [
  'Market Risk',
  'Credit & Counterparty Risk',
  'Regulatory & Capital',
  'Quantitative Methods',
  'Senior Leadership & Governance',
  'Data & Technology',
  'Workflows & Chains',
  'AI/Meta',
  'Liquidity Risk',
];
const CATEGORY_MINIMUMS = {
  'Market Risk': 15,
  'Credit & Counterparty Risk': 10,
  'Regulatory & Capital': 10,
  'Quantitative Methods': 10,
  'Senior Leadership & Governance': 8,
  'Data & Technology': 8,
  'Workflows & Chains': 7,
  'AI/Meta': 4,
  'Liquidity Risk': 3,
};
const CATEGORY_ORDER = categoryOrder;
const PROMPT_LIBRARY = allPrompts;
function computeCategoryCounts(prompts = PROMPT_LIBRARY) {
  const counts = {};
  for (const category of categoryOrder) {
    counts[category] = 0;
  }
  for (const prompt of prompts) {
    counts[prompt.category] = (counts[prompt.category] ?? 0) + 1;
  }
  return counts;
}
function validateCoverage(prompts = PROMPT_LIBRARY) {
  const counts = computeCategoryCounts(prompts);
  const gaps = [];
  for (const [category, minimum] of Object.entries(CATEGORY_MINIMUMS)) {
    if ((counts[category] ?? 0) < minimum) {
      gaps.push({ category, actual: counts[category] ?? 0, minimum });
    }
  }
  return {
    total: prompts.length,
    counts,
    gaps,
    meetsMinimums: gaps.length === 0,
  };
}

window.__CIB_PROMPT_DATA__ = {
  CATEGORY_MINIMUMS,
  CATEGORY_ORDER,
  PROMPT_LIBRARY,
  computeCategoryCounts,
  validateCoverage,
};
})();

const {
  CATEGORY_MINIMUMS,
  CATEGORY_ORDER,
  PROMPT_LIBRARY,
  computeCategoryCounts,
  validateCoverage,
} = window.__CIB_PROMPT_DATA__;

const STORAGE_KEYS = {
  settings: 'cib_prompt_suite_settings_v1',
  promptValues: 'cib_prompt_suite_prompt_values_v1',
  globalVariables: 'cib_prompt_suite_global_variables_v1',
  presets: 'cib_prompt_suite_presets_v1',
  favorites: 'cib_prompt_suite_favorites_v1',
  recents: 'cib_prompt_suite_recents_v1',
  ratings: 'cib_prompt_suite_ratings_v1',
  usage: 'cib_prompt_suite_usage_v1',
  versionUsage: 'cib_prompt_suite_version_usage_v1',
  customPrompts: 'cib_prompt_suite_custom_prompts_v1',
  reviewQueue: 'cib_prompt_suite_review_queue_v1',
  builderState: 'cib_prompt_suite_builder_state_v1',
  workflowState: 'cib_prompt_suite_workflow_state_v1',
};

const NAV_VIEWS = ['home', 'role', 'function', 'workflow', 'builder', 'library'];
const defaultUsageNotes =
  'Use a frontier reasoning model for strongest quantitative quality. Validate assumptions, formulas, and data lineage before production use.';

const state = {
  view: 'home',
  theme: 'dark',
  selectedRole: 'All',
  filters: {
    query: '',
    domain: 'All',
    complexity: 'All',
    regulatory: 'All',
    outputType: 'All',
  },
  prompts: [],
  selectedPromptId: null,
  promptValues: {},
  globalVariables: {},
  presets: {},
  favorites: new Set(),
  recents: [],
  ratings: {},
  usage: {},
  versionUsage: {},
  customPrompts: [],
  reviewQueue: [],
  builder: {
    contextBlocks: [
      { id: crypto.randomUUID(), title: 'AI Persona', content: 'You are a senior CIB risk quant with deep model validation discipline.' },
      { id: crypto.randomUUID(), title: 'Domain Context', content: 'Portfolio spans rates, FX, credit, and equity derivatives with FRTB constraints.' },
      { id: crypto.randomUUID(), title: 'Constraints', content: 'Use explicit assumptions, equations, and regulator-ready structure.' },
    ],
    taskSpec: 'Perform a full risk analysis for the selected portfolio objective.',
    inputSpec: 'Input data includes sensitivities, market moves, and risk limits.',
    outputFormats: ['Table', 'Narrative'],
    guardrails:
      'Do not fabricate unavailable data. Flag assumptions. Distinguish model output from management judgment.',
    chainSteps: [],
    templates: [],
    dragIndex: null,
    chainDragIndex: null,
  },
  workflow: {
    chains: [
      {
        id: crypto.randomUUID(),
        name: 'Morning Risk Triage',
        version: '1.0.0',
        steps: ['G.2', 'A.1.3', 'E.1'],
        updatedAt: new Date().toISOString(),
        history: [{ version: '1.0.0', updatedAt: new Date().toISOString(), steps: ['G.2', 'A.1.3', 'E.1'] }],
      },
    ],
    selectedChainId: null,
  },
};

const els = {
  body: document.body,
  main: document.getElementById('mainContent'),
  nav: document.getElementById('primaryNav'),
  searchInput: document.getElementById('searchInput'),
  domainFilter: document.getElementById('domainFilter'),
  complexityFilter: document.getElementById('complexityFilter'),
  regulatoryFilter: document.getElementById('regulatoryFilter'),
  outputFilter: document.getElementById('outputFilter'),
  statsSummary: document.getElementById('statsSummary'),
  roleSelector: document.getElementById('roleSelector'),
  themeToggle: document.getElementById('themeToggle'),
  openGlobalVars: document.getElementById('openGlobalVars'),
  openCommandPalette: document.getElementById('openCommandPalette'),
  commandPalette: document.getElementById('commandPalette'),
  commandInput: document.getElementById('commandInput'),
  commandResults: document.getElementById('commandResults'),
  forkModal: document.getElementById('forkModal'),
  forkForm: document.getElementById('forkForm'),
  forkTitle: document.getElementById('forkTitle'),
  forkRoles: document.getElementById('forkRoles'),
  forkDomains: document.getElementById('forkDomains'),
  forkComplexity: document.getElementById('forkComplexity'),
  forkPrompt: document.getElementById('forkPrompt'),
  forkUsageNotes: document.getElementById('forkUsageNotes'),
  forkCompliance: document.getElementById('forkCompliance'),
  submitForReview: document.getElementById('submitForReview'),
  globalVarsModal: document.getElementById('globalVarsModal'),
  globalVarEditor: document.getElementById('globalVarEditor'),
  presetNameInput: document.getElementById('presetNameInput'),
  savePresetBtn: document.getElementById('savePresetBtn'),
  presetSelect: document.getElementById('presetSelect'),
  loadPresetBtn: document.getElementById('loadPresetBtn'),
  promptCardTemplate: document.getElementById('promptCardTemplate'),
};

let forkSourcePromptId = null;
let submitReviewFlag = false;
let commandSelectionIndex = 0;

function safeJsonParse(value, fallback) {
  try {
    if (!value) return fallback;
    return JSON.parse(value);
  } catch (_error) {
    return fallback;
  }
}

function asObject(value) {
  return value && typeof value === 'object' && !Array.isArray(value) ? value : {};
}

function asArray(value) {
  return Array.isArray(value) ? value : [];
}

function saveStorage(key, value) {
  localStorage.setItem(key, JSON.stringify(value));
}

function loadStorage(key, fallback) {
  return safeJsonParse(localStorage.getItem(key), fallback);
}

function slugify(value) {
  return String(value || '')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '');
}

function escapeHtml(input) {
  return String(input)
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#039;');
}

function extractPlaceholders(promptText) {
  const matches = [...String(promptText).matchAll(/{{\s*([^}]+?)\s*}}/g)];
  const out = [];
  for (const match of matches) {
    const raw = match[1].trim();
    if (!raw || raw.startsWith('#') || raw.startsWith('/')) continue;
    if (raw.includes('==') || raw.includes('!=') || raw.includes('>') || raw.includes('<')) continue;
    if (!out.includes(raw)) out.push(raw);
  }
  return out;
}

function normalizeVariable(variable, placeholder) {
  if (variable) {
    const label = variable.label || variable.name.replaceAll('_', ' ');
    return {
      ...variable,
      name: variable.name,
      label,
      type: variable.type || 'text',
    };
  }
  return {
    name: placeholder,
    label: placeholder.replaceAll('_', ' '),
    type: 'text',
    default: '',
  };
}

function normalizePrompts(prompts) {
  return prompts.map((prompt) => {
    const placeholders = extractPlaceholders(prompt.prompt);
    const mapped = new Map((prompt.variables || []).map((item) => [item.name, normalizeVariable(item)]));
    for (const placeholder of placeholders) {
      if (!mapped.has(placeholder)) {
        mapped.set(placeholder, normalizeVariable(null, placeholder));
      }
    }
    const versions =
      prompt.versions ||
      [
        {
          version: prompt.version || '1.0.0',
          changedAt: prompt.updatedAt || new Date().toISOString(),
          notes: 'Initial baseline',
          prompt: prompt.prompt,
        },
      ];
    return {
      ...prompt,
      variables: [...mapped.values()],
      version: prompt.version || '1.0.0',
      complianceTag: prompt.complianceTag || 'Internal Use',
      usageNotes: prompt.usageNotes || 'Use a frontier reasoning model and validate numbers before production decisions.',
      versions,
    };
  });
}

function mergeAllPrompts() {
  state.prompts = normalizePrompts([...PROMPT_LIBRARY, ...state.customPrompts]);
}

function loadState() {
  const settings = asObject(loadStorage(STORAGE_KEYS.settings, {}));
  state.theme = settings.theme || 'dark';
  state.selectedRole = settings.selectedRole || 'All';
  state.view = NAV_VIEWS.includes(settings.view) ? settings.view : 'home';

  state.promptValues = asObject(loadStorage(STORAGE_KEYS.promptValues, {}));
  state.globalVariables = asObject(loadStorage(STORAGE_KEYS.globalVariables, {}));
  state.presets = asObject(loadStorage(STORAGE_KEYS.presets, {}));
  state.favorites = new Set(asArray(loadStorage(STORAGE_KEYS.favorites, [])));
  state.recents = asArray(loadStorage(STORAGE_KEYS.recents, []));
  state.ratings = asObject(loadStorage(STORAGE_KEYS.ratings, {}));
  state.usage = asObject(loadStorage(STORAGE_KEYS.usage, {}));
  state.versionUsage = asObject(loadStorage(STORAGE_KEYS.versionUsage, {}));
  state.customPrompts = asArray(loadStorage(STORAGE_KEYS.customPrompts, []));
  state.reviewQueue = asArray(loadStorage(STORAGE_KEYS.reviewQueue, []));

  const builderFromStorage = asObject(loadStorage(STORAGE_KEYS.builderState, null));
  if (builderFromStorage) {
    state.builder = {
      ...state.builder,
      ...builderFromStorage,
    };
  }

  const workflowFromStorage = asObject(loadStorage(STORAGE_KEYS.workflowState, null));
  if (workflowFromStorage) {
    state.workflow = {
      ...state.workflow,
      ...workflowFromStorage,
    };
  }

  mergeAllPrompts();

  if (!state.selectedPromptId && state.prompts[0]) {
    state.selectedPromptId = state.prompts[0].id;
  }
}

function persistState() {
  saveStorage(STORAGE_KEYS.settings, {
    theme: state.theme,
    selectedRole: state.selectedRole,
    view: state.view,
  });
  saveStorage(STORAGE_KEYS.promptValues, state.promptValues);
  saveStorage(STORAGE_KEYS.globalVariables, state.globalVariables);
  saveStorage(STORAGE_KEYS.presets, state.presets);
  saveStorage(STORAGE_KEYS.favorites, [...state.favorites]);
  saveStorage(STORAGE_KEYS.recents, state.recents);
  saveStorage(STORAGE_KEYS.ratings, state.ratings);
  saveStorage(STORAGE_KEYS.usage, state.usage);
  saveStorage(STORAGE_KEYS.versionUsage, state.versionUsage);
  saveStorage(STORAGE_KEYS.customPrompts, state.customPrompts);
  saveStorage(STORAGE_KEYS.reviewQueue, state.reviewQueue);
  saveStorage(STORAGE_KEYS.builderState, state.builder);
  saveStorage(STORAGE_KEYS.workflowState, state.workflow);
}

function formatNumber(value) {
  const numberValue = Number(value);
  if (!Number.isFinite(numberValue)) return String(value);
  return new Intl.NumberFormat('en-US').format(numberValue);
}

function getPromptById(promptId) {
  return state.prompts.find((prompt) => prompt.id === promptId) || null;
}

function coerceValueForVariable(variable, rawValue) {
  if (variable.type === 'multiselect') {
    if (Array.isArray(rawValue)) return rawValue;
    if (typeof rawValue === 'string') {
      return rawValue
        .split(',')
        .map((item) => item.trim())
        .filter(Boolean);
    }
    return [];
  }
  if (variable.type === 'slider' || variable.type === 'number') {
    const maybeNumber = Number(rawValue);
    return Number.isFinite(maybeNumber) ? maybeNumber : rawValue;
  }
  return rawValue;
}

function getPromptValueMap(prompt) {
  const values = {};
  const promptSpecific = state.promptValues[prompt.id] || {};
  for (const variable of prompt.variables) {
    if (promptSpecific[variable.name] !== undefined) {
      values[variable.name] = promptSpecific[variable.name];
      continue;
    }
    if (state.globalVariables[variable.name] !== undefined && state.globalVariables[variable.name] !== '') {
      values[variable.name] = coerceValueForVariable(variable, state.globalVariables[variable.name]);
      continue;
    }
    if (variable.default !== undefined) {
      values[variable.name] = variable.default;
      continue;
    }
    values[variable.name] = variable.type === 'multiselect' ? [] : '';
  }
  return values;
}

function evalCondition(expression, values) {
  const expr = String(expression).trim();
  const comparisonMatch = expr.match(/^(\w+)\s*(==|!=)\s*"([^"]+)"$/);
  if (comparisonMatch) {
    const [, key, op, expected] = comparisonMatch;
    const currentRaw = values[key];
    const currentValue = Array.isArray(currentRaw) ? currentRaw.join(', ') : String(currentRaw ?? '');
    if (op === '==') return currentValue === expected;
    return currentValue !== expected;
  }
  return Boolean(values[expr]);
}

function assemblePrompt(prompt, values) {
  let built = prompt.prompt;
  built = built.replace(/{{#if\s+([^}]+)}}([\s\S]*?){{\/if}}/g, (_match, expression, block) =>
    evalCondition(expression, values) ? block : '',
  );
  built = built.replace(/{{\s*([^}]+?)\s*}}/g, (match, variableName) => {
    const trimmed = String(variableName).trim();
    if (!trimmed || trimmed.startsWith('#') || trimmed.startsWith('/')) return '';
    if (trimmed.includes('==') || trimmed.includes('!=') || trimmed.includes('>') || trimmed.includes('<')) return '';
    const value = values[trimmed];
    if (value === undefined || value === null || value === '') return match;
    if (Array.isArray(value)) return value.join(', ');
    return String(value);
  });
  return built.replace(/\n{3,}/g, '\n\n').trim();
}

function highlightPromptTemplate(promptText) {
  const escaped = escapeHtml(promptText);
  return escaped.replace(/{{\s*([^}]+?)\s*}}/g, (_match, variableName) => {
    return `<span class="slot-token">{{${escapeHtml(String(variableName).trim())}}}</span>`;
  });
}

function incrementUsage(promptId) {
  state.usage[promptId] = (state.usage[promptId] || 0) + 1;
}

function pushRecent(promptId) {
  if (!Array.isArray(state.recents)) {
    state.recents = [];
  }
  state.recents = [promptId, ...state.recents.filter((id) => id !== promptId)].slice(0, 20);
}

function openPrompt(promptId) {
  if (!getPromptById(promptId)) return;
  if (!state.usage || typeof state.usage !== 'object' || Array.isArray(state.usage)) {
    state.usage = {};
  }
  state.selectedPromptId = promptId;
  if (state.view !== 'role' && state.view !== 'function') {
    state.view = 'function';
  }
  pushRecent(promptId);
  incrementUsage(promptId);
  persistState();
  renderMain();
  requestAnimationFrame(() => {
    const detail = document.querySelector('.prompt-detail');
    if (!detail) return;
    detail.classList.add('is-flash');
    detail.scrollIntoView({ behavior: 'smooth', block: 'start' });
    setTimeout(() => detail.classList.remove('is-flash'), 700);
  });
}

function getAllFilterOptions() {
  const domains = new Set(['All']);
  const complexities = new Set(['All']);
  const regulatory = new Set(['All']);
  const outputTypes = new Set(['All']);
  for (const prompt of state.prompts) {
    for (const domain of prompt.domains || []) domains.add(domain);
    if (prompt.complexity) complexities.add(prompt.complexity);
    for (const item of prompt.regulatory || []) regulatory.add(item);
    for (const item of prompt.outputTypes || []) outputTypes.add(item);
  }
  return {
    domains: [...domains],
    complexities: [...complexities],
    regulatory: [...regulatory],
    outputTypes: [...outputTypes],
  };
}

function renderFilterSelect(element, options, selectedValue) {
  element.innerHTML = options
    .map((option) => `<option value="${escapeHtml(option)}" ${option === selectedValue ? 'selected' : ''}>${escapeHtml(option)}</option>`)
    .join('');
}

function setupFilters() {
  const options = getAllFilterOptions();
  renderFilterSelect(els.domainFilter, options.domains, state.filters.domain);
  renderFilterSelect(els.complexityFilter, options.complexities, state.filters.complexity);
  renderFilterSelect(els.regulatoryFilter, options.regulatory, state.filters.regulatory);
  renderFilterSelect(els.outputFilter, options.outputTypes, state.filters.outputType);
  els.roleSelector.value = state.selectedRole;
  els.searchInput.value = state.filters.query;
}

function filteredPrompts() {
  const query = state.filters.query.trim().toLowerCase();
  return state.prompts.filter((prompt) => {
    if (state.selectedRole !== 'All' && !(prompt.roles || []).includes(state.selectedRole)) return false;
    if (state.filters.domain !== 'All' && !(prompt.domains || []).includes(state.filters.domain)) return false;
    if (state.filters.complexity !== 'All' && prompt.complexity !== state.filters.complexity) return false;
    if (state.filters.regulatory !== 'All' && !(prompt.regulatory || []).includes(state.filters.regulatory)) return false;
    if (state.filters.outputType !== 'All' && !(prompt.outputTypes || []).includes(state.filters.outputType)) return false;

    if (!query) return true;
    const haystack = [
      prompt.id,
      prompt.title,
      prompt.category,
      prompt.section,
      ...(prompt.roles || []),
      ...(prompt.domains || []),
      ...(prompt.regulatory || []),
      ...(prompt.outputTypes || []),
      prompt.prompt,
    ]
      .join(' ')
      .toLowerCase();

    return haystack.includes(query);
  });
}

function getTopPromptIdsByUsage(limit = 10) {
  return Object.entries(state.usage)
    .sort((a, b) => b[1] - a[1])
    .slice(0, limit)
    .map(([id]) => id)
    .filter((id) => getPromptById(id));
}

function getSuggestionsForPrompt(prompt) {
  const explicit = (prompt.related || []).map((id) => getPromptById(id)).filter(Boolean);
  const domainBased = state.prompts
    .filter((candidate) => candidate.id !== prompt.id)
    .map((candidate) => {
      const overlap = (candidate.domains || []).filter((domain) => (prompt.domains || []).includes(domain)).length;
      return { candidate, overlap };
    })
    .filter((item) => item.overlap > 0)
    .sort((a, b) => b.overlap - a.overlap)
    .slice(0, 5)
    .map((item) => item.candidate);

  const combined = [...explicit, ...domainBased];
  const unique = [];
  const seen = new Set();
  for (const item of combined) {
    if (seen.has(item.id)) continue;
    seen.add(item.id);
    unique.push(item);
  }
  return unique.slice(0, 5);
}

function buildTag(label, className = '') {
  return `<span class="tag ${className}">${escapeHtml(label)}</span>`;
}

function complexityClass(complexity) {
  const value = String(complexity || '').toLowerCase();
  if (value.includes('quick')) return 'quick';
  if (value.includes('deep')) return 'deep';
  return 'configurable';
}

function renderStats() {
  const coverage = validateCoverage(state.prompts);
  const counts = computeCategoryCounts(state.prompts);
  const favoriteCount = state.favorites.size;
  const recentCount = state.recents.length;
  const total = coverage.total;
  const gaps = coverage.gaps.length;

  els.statsSummary.innerHTML = `
    <div><span class="inline-strong">${formatNumber(total)}</span> prompts loaded</div>
    <div><span class="inline-strong">${formatNumber(favoriteCount)}</span> favorites</div>
    <div><span class="inline-strong">${formatNumber(recentCount)}</span> recent</div>
    <div><span class="inline-strong">${coverage.meetsMinimums ? 'Yes' : 'No'}</span> checklist coverage</div>
    <div><span class="inline-strong">${formatNumber(gaps)}</span> category gaps</div>
    <div class="badge">Market: ${counts['Market Risk'] || 0}/${CATEGORY_MINIMUMS['Market Risk']}</div>
    <div class="badge">Credit: ${counts['Credit & Counterparty Risk'] || 0}/${CATEGORY_MINIMUMS['Credit & Counterparty Risk']}</div>
    <div class="badge">Reg/Cap: ${counts['Regulatory & Capital'] || 0}/${CATEGORY_MINIMUMS['Regulatory & Capital']}</div>
  `;
}

function setTheme(theme) {
  state.theme = theme;
  if (state.theme === 'light') {
    els.body.classList.add('theme-light');
    els.themeToggle.textContent = 'Dark Mode';
  } else {
    els.body.classList.remove('theme-light');
    els.themeToggle.textContent = 'Light Mode';
  }
}

function renderNav() {
  for (const button of els.nav.querySelectorAll('.nav-item')) {
    button.classList.toggle('is-active', button.dataset.view === state.view);
  }
}

function promptCardFragment(prompt) {
  const fragment = els.promptCardTemplate.content.cloneNode(true);
  const card = fragment.querySelector('.prompt-card');
  const titleEl = fragment.querySelector('.prompt-title');
  const tagRow = fragment.querySelector('.tag-row');
  const versionPill = fragment.querySelector('.version-pill');
  const complexityPill = fragment.querySelector('.complexity-pill');
  const compliancePill = fragment.querySelector('.compliance-pill');
  const snippet = fragment.querySelector('.prompt-snippet');
  const openBtn = fragment.querySelector('.open-btn');
  const forkBtn = fragment.querySelector('.fork-btn');
  const favBtn = fragment.querySelector('.fav-btn');

  titleEl.textContent = `${prompt.id}: ${prompt.title}`;
  const roleTags = (prompt.roles || []).slice(0, 3).map((role) => buildTag(role, `role-${slugify(role)}`));
  const domainTags = (prompt.domains || []).slice(0, 2).map((domain) => buildTag(domain));
  tagRow.innerHTML = [...roleTags, ...domainTags].join('');

  const lastUsedVersion = state.versionUsage[prompt.id];
  const isUpdated = lastUsedVersion && lastUsedVersion !== prompt.version;
  versionPill.textContent = isUpdated
    ? `v${prompt.version} (new)`
    : `v${prompt.version}${lastUsedVersion ? '' : ' (unopened)'}`;

  complexityPill.textContent = prompt.complexity;
  complexityPill.classList.add(complexityClass(prompt.complexity));
  compliancePill.textContent = prompt.complianceTag;

  const compactPrompt = prompt.prompt.slice(0, 230).replace(/\s+/g, ' ').trim();
  snippet.textContent = `${compactPrompt}${prompt.prompt.length > 230 ? '...' : ''}`;

  card.dataset.promptId = prompt.id;
  card.classList.toggle('is-selected', prompt.id === state.selectedPromptId);
  openBtn.dataset.action = 'open-prompt';
  openBtn.dataset.promptId = prompt.id;
  openBtn.textContent = prompt.id === state.selectedPromptId ? 'Open (Active)' : 'Open';

  forkBtn.dataset.action = 'fork-prompt';
  forkBtn.dataset.promptId = prompt.id;

  favBtn.dataset.action = 'toggle-favorite';
  favBtn.dataset.promptId = prompt.id;
  favBtn.textContent = state.favorites.has(prompt.id) ? 'Favorited' : 'Favorite';

  return fragment;
}

function renderPromptGrid(prompts) {
  if (!prompts.length) {
    return '<div class="empty-state">No prompts match your current role/filter criteria.</div>';
  }
  const wrapper = document.createElement('div');
  wrapper.className = 'prompt-grid';
  for (const prompt of prompts) {
    wrapper.append(promptCardFragment(prompt));
  }
  return wrapper.outerHTML;
}

function renderMetricCards(prompts) {
  const usageLeaders = getTopPromptIdsByUsage(1);
  const usageLeader = usageLeaders[0] ? getPromptById(usageLeaders[0]) : null;
  const coverage = validateCoverage(state.prompts);
  return `
    <div class="metric-grid">
      <article class="metric-card">
        <span class="label">Visible Prompts</span>
        <span class="value">${formatNumber(prompts.length)}</span>
      </article>
      <article class="metric-card">
        <span class="label">Total Library</span>
        <span class="value">${formatNumber(state.prompts.length)}</span>
      </article>
      <article class="metric-card">
        <span class="label">Top Used Prompt</span>
        <span class="value" style="font-size:14px">${usageLeader ? escapeHtml(usageLeader.title) : 'No usage yet'}</span>
      </article>
      <article class="metric-card">
        <span class="label">Category Minimums</span>
        <span class="value" style="font-size:14px">${coverage.meetsMinimums ? 'Met' : 'Gap(s) found'}</span>
      </article>
    </div>
  `;
}

function renderHome() {
  const rolePrioritized = state.prompts.filter(
    (prompt) => state.selectedRole === 'All' || (prompt.roles || []).includes(state.selectedRole),
  );
  const topByUsage = getTopPromptIdsByUsage(8).map((id) => getPromptById(id)).filter(Boolean);
  const recentPrompts = state.recents.map((id) => getPromptById(id)).filter(Boolean).slice(0, 8);
  const recommended = rolePrioritized.slice(0, 8);
  const coverage = validateCoverage(state.prompts);

  const renderSimpleButtons = (items) =>
    items.length
      ? items
          .map(
            (prompt) =>
              `<button data-action="open-prompt" data-prompt-id="${escapeHtml(prompt.id)}">${escapeHtml(
                `${prompt.id}: ${prompt.title}`,
              )}</button>`,
          )
          .join('')
      : '<div class="item">No entries yet</div>';

  const coverageRows = CATEGORY_ORDER.map((category) => {
    const actual = coverage.counts[category] || 0;
    const minimum = CATEGORY_MINIMUMS[category] || 0;
    const status = actual >= minimum ? 'OK' : 'Gap';
    return `<div class="item">${escapeHtml(category)}: <span class="inline-strong">${actual}/${minimum}</span> (${status})</div>`;
  }).join('');

  els.main.innerHTML = `
    <section class="view-header">
      <div>
        <h2>Role-Personalized Home</h2>
        <p>Command palette <span class="kbd">Ctrl+K</span> for instant navigation. Current role focus: <span class="inline-strong">${escapeHtml(
          state.selectedRole,
        )}</span>.</p>
      </div>
    </section>

    <section class="home-grid">
      <article class="home-panel">
        <h3>Recommended for ${escapeHtml(state.selectedRole)}</h3>
        <div class="simple-list">${renderSimpleButtons(recommended)}</div>
      </article>

      <article class="home-panel">
        <h3>Trending and Recent</h3>
        <div class="simple-list">
          <div class="item"><span class="inline-strong">Trending</span></div>
          ${renderSimpleButtons(topByUsage)}
          <div class="item"><span class="inline-strong">Recent</span></div>
          ${renderSimpleButtons(recentPrompts)}
        </div>
      </article>

      <article class="home-panel">
        <h3>Coverage and Governance</h3>
        <div class="simple-list">
          <div class="item">Total prompts: <span class="inline-strong">${coverage.total}</span></div>
          <div class="item">Checklist status: <span class="inline-strong">${coverage.meetsMinimums ? 'Complete' : 'Incomplete'}</span></div>
          ${coverageRows}
        </div>
      </article>
    </section>
  `;
}

function buildVariableInput(prompt, variable, currentValue) {
  const variableId = `${prompt.id}:${variable.name}`;
  const baseData = `data-action="set-var" data-prompt-id="${escapeHtml(prompt.id)}" data-var-name="${escapeHtml(variable.name)}"`;
  const commonLabel = `<div class="meta-line"><span>${escapeHtml(variable.label)}</span><button class="icon-btn" data-action="set-global-from-var" data-prompt-id="${escapeHtml(
    prompt.id,
  )}" data-var-name="${escapeHtml(variable.name)}">Set Global</button></div>`;

  if (variable.type === 'select') {
    const options = (variable.options || [])
      .map((option) => {
        const selected = String(option) === String(currentValue) ? 'selected' : '';
        return `<option value="${escapeHtml(option)}" ${selected}>${escapeHtml(option)}</option>`;
      })
      .join('');
    return `<label class="variable-input">${commonLabel}<select id="${escapeHtml(variableId)}" ${baseData}>${options}</select></label>`;
  }

  if (variable.type === 'multiselect') {
    const currentSet = new Set(Array.isArray(currentValue) ? currentValue.map(String) : []);
    const options = (variable.options || [])
      .map((option) => {
        const selected = currentSet.has(String(option)) ? 'selected' : '';
        return `<option value="${escapeHtml(option)}" ${selected}>${escapeHtml(option)}</option>`;
      })
      .join('');
    return `<label class="variable-input">${commonLabel}<select multiple id="${escapeHtml(variableId)}" ${baseData}>${options}</select></label>`;
  }

  if (variable.type === 'slider') {
    const current = currentValue ?? variable.default ?? variable.min ?? 0;
    return `<label class="variable-input">${commonLabel}
      <div class="range-row">
        <input type="range" min="${variable.min ?? 0}" max="${variable.max ?? 100}" step="${variable.step ?? 1}" value="${escapeHtml(
          current,
        )}" id="${escapeHtml(variableId)}" ${baseData} />
        <span class="range-value" data-range-value="${escapeHtml(`${prompt.id}|${variable.name}`)}">${escapeHtml(
          String(current),
        )}</span>
      </div>
    </label>`;
  }

  if (variable.type === 'textarea') {
    return `<label class="variable-input">${commonLabel}<textarea rows="4" id="${escapeHtml(variableId)}" ${baseData}>${escapeHtml(
      currentValue ?? '',
    )}</textarea></label>`;
  }

  const inputType = variable.type === 'date' ? 'date' : variable.type === 'number' ? 'number' : 'text';
  return `<label class="variable-input">${commonLabel}<input type="${inputType}" id="${escapeHtml(variableId)}" value="${escapeHtml(
    currentValue ?? '',
  )}" ${baseData} /></label>`;
}

function renderSuggestions(prompt) {
  const suggestions = getSuggestionsForPrompt(prompt);
  if (!suggestions.length) {
    return '<div class="item">No suggestions available yet.</div>';
  }
  return suggestions
    .map(
      (item) =>
        `<button data-action="open-prompt" data-prompt-id="${escapeHtml(item.id)}">${escapeHtml(
          `${item.id}: ${item.title}`,
        )}</button>`,
    )
    .join('');
}

function renderVersionDiff(prompt) {
  const history = prompt.versions || [];
  if (history.length < 2) {
    return '<div class="item">Version history: initial baseline only.</div>';
  }
  const latest = history[history.length - 1];
  const previous = history[history.length - 2];
  const latestLines = new Set(String(latest.prompt || '').split('\n'));
  const previousLines = new Set(String(previous.prompt || '').split('\n'));
  const added = [...latestLines].filter((line) => !previousLines.has(line) && line.trim()).slice(0, 5);
  const removed = [...previousLines].filter((line) => !latestLines.has(line) && line.trim()).slice(0, 5);
  const additions = added.length
    ? `<div class="item"><span class="inline-strong">Added:</span><br/>${escapeHtml(added.join('\n'))}</div>`
    : '<div class="item">No added lines.</div>';
  const removals = removed.length
    ? `<div class="item"><span class="inline-strong">Removed:</span><br/>${escapeHtml(removed.join('\n'))}</div>`
    : '<div class="item">No removed lines.</div>';
  return `${additions}${removals}`;
}

function promptDetailHtml(prompt) {
  const values = getPromptValueMap(prompt);
  const assembled = assemblePrompt(prompt, values);
  const variableInputs = prompt.variables.map((variable) => buildVariableInput(prompt, variable, values[variable.name])).join('');
  const rating = state.ratings[prompt.id] || { rating: 0, feedback: '' };
  const stars = [1, 2, 3, 4, 5]
    .map(
      (star) =>
        `<button class="star-btn ${rating.rating >= star ? 'active' : ''}" data-action="set-rating" data-prompt-id="${escapeHtml(
          prompt.id,
        )}" data-rating="${star}">${star}</button>`,
    )
    .join('');

  const lastUsedVersion = state.versionUsage[prompt.id];
  const versionLabel = lastUsedVersion
    ? `Last used version: ${escapeHtml(lastUsedVersion)}${lastUsedVersion !== prompt.version ? ' (update available)' : ''}`
    : 'Never copied/exported yet';

  return `
    <section class="prompt-detail">
      <article class="panel">
        <header class="panel-header">
          <div>
            <h3>${escapeHtml(prompt.id)} - ${escapeHtml(prompt.title)}</h3>
            <div class="meta">${escapeHtml(prompt.category)} | ${escapeHtml(prompt.section)} | ${escapeHtml(versionLabel)}</div>
          </div>
        </header>
        <div class="panel-body">
          <div class="variables-grid">${variableInputs}</div>
          <div>
            <h4>Prompt Template</h4>
            <pre class="prompt-code">${highlightPromptTemplate(prompt.prompt)}</pre>
          </div>
          <div class="action-row">
            <button class="primary-btn" data-action="copy-prompt" data-prompt-id="${escapeHtml(prompt.id)}">Copy Assembled Prompt</button>
            <button class="ghost-btn" data-action="export-json" data-prompt-id="${escapeHtml(prompt.id)}">Export JSON</button>
            <button class="ghost-btn" data-action="export-pdf" data-prompt-id="${escapeHtml(prompt.id)}">Export PDF</button>
            <button class="ghost-btn" data-action="fork-prompt" data-prompt-id="${escapeHtml(prompt.id)}">Fork & Edit</button>
            <button class="ghost-btn" data-action="toggle-favorite" data-prompt-id="${escapeHtml(prompt.id)}">${
              state.favorites.has(prompt.id) ? 'Remove Favorite' : 'Add Favorite'
            }</button>
          </div>

          <div class="feedback-block">
            <h4>Rating and Feedback</h4>
            <div class="star-row">${stars}</div>
            <textarea rows="3" placeholder="What should improve?" data-action="set-feedback" data-prompt-id="${escapeHtml(
              prompt.id,
            )}">${escapeHtml(rating.feedback || '')}</textarea>
          </div>

          <div>
            <h4>Version Diff View</h4>
            <div class="simple-list">${renderVersionDiff(prompt)}</div>
          </div>
        </div>
      </article>

      <article class="panel preview-pane">
        <header class="panel-header">
          <div>
            <h3>Assembled Prompt Preview</h3>
            <div class="meta">Complexity: ${escapeHtml(prompt.complexity)} | Compliance: ${escapeHtml(prompt.complianceTag)}</div>
          </div>
        </header>
        <div class="usage-notes">
          <strong>Usage Notes:</strong> ${escapeHtml(prompt.usageNotes)}
        </div>
        <div class="panel-body preview-output">
          <pre id="assembledPreview">${escapeHtml(assembled)}</pre>
          <h4>Smart Suggestions</h4>
          <div class="simple-list">${renderSuggestions(prompt)}</div>
        </div>
      </article>
    </section>
  `;
}

function renderPromptBrowser(viewMode) {
  const prompts = filteredPrompts();
  const selectedPrompt = getPromptById(state.selectedPromptId) || prompts[0] || null;

  const titleMap = {
    role: 'By Role',
    function: 'By Function',
  };

  els.main.innerHTML = `
    <section class="view-header">
      <div>
        <h2>${escapeHtml(titleMap[viewMode] || 'Prompt Library')}</h2>
        <p>Use filters for role/domain/regulatory scope, then open a prompt to configure variables and copy production-ready text.</p>
      </div>
      <div class="btn-row">
        <button class="ghost-btn" data-action="batch-export">Batch Export Current View</button>
      </div>
    </section>
    ${renderMetricCards(prompts)}
    ${selectedPrompt ? promptDetailHtml(selectedPrompt) : '<div class="empty-state">Select a prompt card to begin.</div>'}
    <section class="view-header" style="margin-top: 12px;">
      <div>
        <h2>Prompt Cards</h2>
        <p>Click <span class="inline-strong">Open</span> to load a prompt into the workspace above.</p>
      </div>
    </section>
    ${renderPromptGrid(prompts)}
  `;
}

function builderGeneratedPrompt() {
  const lines = [];
  lines.push('You are an expert CIB risk analytics assistant.');
  lines.push('');
  lines.push('Context blocks:');
  state.builder.contextBlocks.forEach((block, index) => {
    lines.push(`${index + 1}. ${block.title}: ${block.content}`);
  });
  lines.push('');
  lines.push(`Task specification: ${state.builder.taskSpec}`);
  lines.push(`Input specification: ${state.builder.inputSpec}`);
  lines.push(`Output formats required: ${(state.builder.outputFormats || []).join(', ') || 'Narrative'}`);
  lines.push(`Constraints and guardrails: ${state.builder.guardrails}`);
  if (state.builder.chainSteps.length) {
    lines.push('');
    lines.push('Execution chain:');
    state.builder.chainSteps.forEach((stepPromptId, idx) => {
      const prompt = getPromptById(stepPromptId);
      lines.push(`${idx + 1}. ${prompt ? `${prompt.id}: ${prompt.title}` : stepPromptId}`);
    });
  }
  lines.push('');
  lines.push(
    'Produce output with explicit assumptions, formula references where relevant, and a final section listing data gaps and validation checks.',
  );
  return lines.join('\n');
}

function renderBuilder() {
  const allPromptOptions = state.prompts
    .map((prompt) => `<option value="${escapeHtml(prompt.id)}">${escapeHtml(`${prompt.id}: ${prompt.title}`)}</option>`)
    .join('');

  const contextRows = state.builder.contextBlocks
    .map(
      (block, index) => `
      <div class="drag-item" draggable="true" data-builder-drag="context" data-index="${index}">
        <strong>${escapeHtml(block.title)}</strong>
        <p>${escapeHtml(block.content)}</p>
        <div class="btn-row">
          <button class="icon-btn" data-action="remove-context" data-index="${index}">Remove</button>
        </div>
      </div>`,
    )
    .join('');

  const chainRows = state.builder.chainSteps
    .map((stepId, index) => {
      const prompt = getPromptById(stepId);
      return `<div class="drag-item" draggable="true" data-builder-drag="chain" data-index="${index}">
        <strong>Step ${index + 1}</strong>
        <p>${escapeHtml(prompt ? `${prompt.id}: ${prompt.title}` : stepId)}</p>
        <button class="icon-btn" data-action="remove-chain-step" data-index="${index}">Remove</button>
      </div>`;
    })
    .join('');

  const templateRows = (state.builder.templates || [])
    .map(
      (template) =>
        `<div class="workflow-step"><span>${escapeHtml(template.name)} <span class="badge">${escapeHtml(
          template.version,
        )}</span></span><div class="btn-row"><button class="icon-btn" data-action="load-builder-template" data-template-id="${escapeHtml(
          template.id,
        )}">Load</button><button class="icon-btn" data-action="delete-builder-template" data-template-id="${escapeHtml(
          template.id,
        )}">Delete</button></div></div>`,
    )
    .join('');

  els.main.innerHTML = `
    <section class="view-header">
      <div>
        <h2>Dynamic Prompt Builder</h2>
        <p>Drag context blocks, define tasks/constraints, chain reusable prompts, and save templates.</p>
      </div>
    </section>

    <section class="builder-grid">
      <article class="builder-panel">
        <h3>Context Block Builder</h3>
        <div class="draggable-list" id="contextDragZone">${contextRows || '<div class="empty-state">No blocks yet.</div>'}</div>

        <label>New Block Title<input id="builderNewTitle" placeholder="e.g., Regulatory Context" /></label>
        <label>New Block Content<textarea id="builderNewContent" rows="3" placeholder="Describe assumptions, scope, and constraints."></textarea></label>
        <button class="primary-btn" data-action="add-context">Add Context Block</button>

        <h3>Task Specification</h3>
        <label>Task<textarea id="builderTaskSpec" rows="3" data-action="builder-field" data-field="taskSpec">${escapeHtml(
          state.builder.taskSpec,
        )}</textarea></label>
        <label>Input Spec<textarea id="builderInputSpec" rows="3" data-action="builder-field" data-field="inputSpec">${escapeHtml(
          state.builder.inputSpec,
        )}</textarea></label>

        <h3>Output Format Designer</h3>
        <label><input type="checkbox" data-action="toggle-output-format" value="Table" ${
          state.builder.outputFormats.includes('Table') ? 'checked' : ''
        } /> Table</label>
        <label><input type="checkbox" data-action="toggle-output-format" value="Narrative" ${
          state.builder.outputFormats.includes('Narrative') ? 'checked' : ''
        } /> Narrative</label>
        <label><input type="checkbox" data-action="toggle-output-format" value="JSON" ${
          state.builder.outputFormats.includes('JSON') ? 'checked' : ''
        } /> JSON</label>
        <label><input type="checkbox" data-action="toggle-output-format" value="Markdown" ${
          state.builder.outputFormats.includes('Markdown') ? 'checked' : ''
        } /> Markdown</label>
        <label><input type="checkbox" data-action="toggle-output-format" value="LaTeX" ${
          state.builder.outputFormats.includes('LaTeX') ? 'checked' : ''
        } /> LaTeX</label>

        <h3>Constraint and Guardrail Editor</h3>
        <textarea rows="4" data-action="builder-field" data-field="guardrails">${escapeHtml(state.builder.guardrails)}</textarea>
      </article>

      <article class="builder-panel">
        <h3>Chain Builder</h3>
        <div class="btn-row">
          <select id="builderChainPrompt">${allPromptOptions}</select>
          <button class="ghost-btn" data-action="add-chain-step">Add Step</button>
        </div>
        <div class="draggable-list" id="chainDragZone">${chainRows || '<div class="empty-state">No chain steps yet.</div>'}</div>

        <h3>Assembled Builder Output</h3>
        <pre class="prompt-code">${escapeHtml(builderGeneratedPrompt())}</pre>
        <div class="btn-row">
          <button class="primary-btn" data-action="copy-builder">Copy Builder Prompt</button>
          <button class="ghost-btn" data-action="export-builder-json">Export Builder JSON</button>
        </div>

        <h3>Template Save</h3>
        <div class="btn-row">
          <input id="builderTemplateName" placeholder="Template name" />
          <button class="ghost-btn" data-action="save-builder-template">Save Template</button>
        </div>
        <div class="draggable-list">${templateRows || '<div class="empty-state">No templates saved.</div>'}</div>
      </article>
    </section>
  `;
}

function renderWorkflow() {
  const allPromptOptions = state.prompts
    .map((prompt) => `<option value="${escapeHtml(prompt.id)}">${escapeHtml(`${prompt.id}: ${prompt.title}`)}</option>`)
    .join('');

  const chains = state.workflow.chains || [];
  const selectedChain =
    chains.find((chain) => chain.id === state.workflow.selectedChainId) || chains[0] || null;

  const chainListRows = chains
    .map(
      (chain) =>
        `<button class="item" data-action="select-chain" data-chain-id="${escapeHtml(chain.id)}">${escapeHtml(
          chain.name,
        )} <span class="badge">v${escapeHtml(chain.version)}</span></button>`,
    )
    .join('');

  const chainStepsRows = selectedChain
    ? selectedChain.steps
        .map((stepId, index) => {
          const prompt = getPromptById(stepId);
          return `<div class="workflow-step" draggable="true" data-workflow-drag="step" data-index="${index}">
            <span>${escapeHtml(prompt ? `${prompt.id}: ${prompt.title}` : stepId)}</span>
            <div class="btn-row">
              <button class="icon-btn" data-action="remove-workflow-step" data-index="${index}">Remove</button>
            </div>
          </div>`;
        })
        .join('')
    : '<div class="empty-state">Create a chain to begin.</div>';

  const chainHistoryRows = selectedChain
    ? (selectedChain.history || [])
        .slice()
        .reverse()
        .map((item) => `<div class="item">v${escapeHtml(item.version)} - ${escapeHtml(new Date(item.updatedAt).toLocaleString())}</div>`)
        .join('')
    : '<div class="item">No history.</div>';

  els.main.innerHTML = `
    <section class="view-header">
      <div>
        <h2>Prompt Chaining Workspace</h2>
        <p>Create, version, and run reusable step chains where step output context flows into the next step.</p>
      </div>
    </section>

    <section class="workflow-grid">
      <article class="builder-panel">
        <h3>Workflow Templates</h3>
        <div class="simple-list">${chainListRows || '<div class="item">No chains yet.</div>'}</div>

        <h3>Create New Chain</h3>
        <label>Name<input id="workflowName" placeholder="e.g., Weekly Validation Run" /></label>
        <button class="primary-btn" data-action="create-chain">Create Chain</button>
      </article>

      <article class="builder-panel">
        <h3>${selectedChain ? escapeHtml(selectedChain.name) : 'Chain Editor'}</h3>
        <div class="btn-row">
          <select id="workflowStepPrompt">${allPromptOptions}</select>
          <button class="ghost-btn" data-action="add-workflow-step">Add Step</button>
          <button class="ghost-btn" data-action="save-workflow-version">Save New Version</button>
          <button class="ghost-btn" data-action="export-workflow-json">Export Chain JSON</button>
        </div>

        <div class="draggable-list" id="workflowStepZone">${chainStepsRows}</div>

        <h3>Version History</h3>
        <div class="simple-list">${chainHistoryRows}</div>
      </article>
    </section>
  `;
}

function renderLibrary() {
  const favorites = [...state.favorites].map((id) => getPromptById(id)).filter(Boolean);
  const recents = state.recents.map((id) => getPromptById(id)).filter(Boolean);
  const customPrompts = state.customPrompts;

  const promptButtonList = (items) =>
    items.length
      ? items
          .map(
            (prompt) =>
              `<button data-action="open-prompt" data-prompt-id="${escapeHtml(prompt.id)}">${escapeHtml(
                `${prompt.id}: ${prompt.title}`,
              )}</button>`,
          )
          .join('')
      : '<div class="item">No items.</div>';

  const reviewRows = state.reviewQueue.length
    ? state.reviewQueue
        .map((item) => {
          const status = item.status || 'Pending';
          return `<div class="workflow-step">
            <span>${escapeHtml(item.title)} <span class="badge">${escapeHtml(status)}</span></span>
            <div class="btn-row">
              <button class="icon-btn" data-action="open-prompt" data-prompt-id="${escapeHtml(item.promptId)}">Open</button>
              <button class="icon-btn" data-action="approve-review" data-review-id="${escapeHtml(item.id)}">Approve</button>
              <button class="icon-btn" data-action="reject-review" data-review-id="${escapeHtml(item.id)}">Reject</button>
            </div>
          </div>`;
        })
        .join('')
    : '<div class="item">No review submissions yet.</div>';

  els.main.innerHTML = `
    <section class="view-header">
      <div>
        <h2>My Library</h2>
        <p>Manage favorites, recents, custom forks, and peer-review workflow queue.</p>
      </div>
    </section>

    <section class="home-grid">
      <article class="home-panel">
        <h3>Favorites</h3>
        <div class="simple-list">${promptButtonList(favorites)}</div>
      </article>
      <article class="home-panel">
        <h3>Recent</h3>
        <div class="simple-list">${promptButtonList(recents)}</div>
      </article>
      <article class="home-panel">
        <h3>Custom Prompts (${customPrompts.length})</h3>
        <div class="simple-list">${promptButtonList(customPrompts)}</div>
      </article>
    </section>

    <section class="builder-panel" style="margin-top:12px;">
      <h3>Team Sharing and Review Workflow</h3>
      <div class="draggable-list">${reviewRows}</div>
    </section>
  `;
}

function renderMain() {
  renderNav();
  renderStats();

  if (state.view === 'home') {
    renderHome();
  } else if (state.view === 'role') {
    renderPromptBrowser('role');
  } else if (state.view === 'function') {
    renderPromptBrowser('function');
  } else if (state.view === 'builder') {
    renderBuilder();
  } else if (state.view === 'workflow') {
    renderWorkflow();
  } else if (state.view === 'library') {
    renderLibrary();
  } else {
    renderHome();
  }
}

function openOverlay(overlayElement) {
  overlayElement.classList.remove('hidden');
}

function closeOverlay(overlayElement) {
  overlayElement.classList.add('hidden');
}

function renderCommandPalette(query = '') {
  const normalized = query.trim().toLowerCase();
  const actions = [
    { type: 'action', label: 'Go to Home', value: 'view:home' },
    { type: 'action', label: 'Go to By Role', value: 'view:role' },
    { type: 'action', label: 'Go to By Function', value: 'view:function' },
    { type: 'action', label: 'Go to Builder', value: 'view:builder' },
    { type: 'action', label: 'Go to Workflow', value: 'view:workflow' },
    { type: 'action', label: 'Go to My Library', value: 'view:library' },
  ];

  const promptMatches = state.prompts
    .filter((prompt) => {
      if (!normalized) return true;
      const haystack = `${prompt.id} ${prompt.title} ${(prompt.domains || []).join(' ')}`.toLowerCase();
      return haystack.includes(normalized);
    })
    .slice(0, 14)
    .map((prompt) => ({
      type: 'prompt',
      label: `${prompt.id}: ${prompt.title}`,
      sub: `${prompt.category} | ${(prompt.domains || []).join(', ')}`,
      value: prompt.id,
    }));

  const filteredActions = actions.filter((action) => {
    if (!normalized) return true;
    return action.label.toLowerCase().includes(normalized);
  });

  const items = [...filteredActions, ...promptMatches];
  commandSelectionIndex = Math.max(0, Math.min(commandSelectionIndex, items.length - 1));

  els.commandResults.innerHTML = items.length
    ? items
        .map((item, index) => {
          const cls = index === commandSelectionIndex ? 'command-item active' : 'command-item';
          return `<div class="${cls}" data-action="run-command-item" data-command-type="${escapeHtml(
            item.type,
          )}" data-command-value="${escapeHtml(item.value)}">
            <div>${escapeHtml(item.label)}</div>
            <small>${escapeHtml(item.sub || (item.type === 'action' ? 'Navigation action' : 'Prompt'))}</small>
          </div>`;
        })
        .join('')
    : '<div class="empty-state">No results</div>';
}

function openCommandPalette() {
  openOverlay(els.commandPalette);
  els.commandInput.value = '';
  commandSelectionIndex = 0;
  renderCommandPalette('');
  els.commandInput.focus();
}

function runCommand(type, value) {
  if (type === 'action' && value.startsWith('view:')) {
    state.view = value.split(':')[1];
    closeOverlay(els.commandPalette);
    persistState();
    renderMain();
    return;
  }
  if (type === 'prompt') {
    state.view = 'function';
    state.selectedPromptId = value;
    closeOverlay(els.commandPalette);
    openPrompt(value);
  }
}

function openForkModal(prompt) {
  forkSourcePromptId = prompt.id;
  submitReviewFlag = false;
  els.forkForm.dataset.submitReview = 'false';
  els.forkTitle.value = `${prompt.title} (Fork)`;
  els.forkRoles.value = (prompt.roles || []).join(', ');
  els.forkDomains.value = (prompt.domains || []).join(', ');
  els.forkComplexity.value = prompt.complexity || 'Configurable';
  els.forkPrompt.value = prompt.prompt;
  els.forkUsageNotes.value = prompt.usageNotes || '';
  els.forkCompliance.value = prompt.complianceTag || 'Internal Use';
  openOverlay(els.forkModal);
}

function downloadJson(filename, data) {
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const anchor = document.createElement('a');
  anchor.href = url;
  anchor.download = filename;
  anchor.click();
  URL.revokeObjectURL(url);
}

async function copyText(text) {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (_error) {
    return false;
  }
}

function exportPromptPdfLike(prompt, assembled) {
  const popup = window.open('', '_blank', 'width=980,height=780');
  if (!popup) return;
  popup.document.write(`
    <html>
      <head>
        <title>${escapeHtml(prompt.id)} - ${escapeHtml(prompt.title)}</title>
        <style>
          body { font-family: Georgia, serif; padding: 24px; color: #0f172a; }
          h1 { margin: 0 0 4px 0; font-size: 20px; }
          p.meta { margin: 0 0 16px 0; color: #475569; }
          pre { white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.45; }
        </style>
      </head>
      <body>
        <h1>${escapeHtml(prompt.id)}: ${escapeHtml(prompt.title)}</h1>
        <p class="meta">Version ${escapeHtml(prompt.version)} | Compliance: ${escapeHtml(prompt.complianceTag)}</p>
        <pre>${escapeHtml(assembled)}</pre>
      </body>
    </html>
  `);
  popup.document.close();
  popup.focus();
  popup.print();
}

function renderGlobalVariablesEditor() {
  const variableMap = new Map();
  for (const prompt of state.prompts) {
    for (const variable of prompt.variables || []) {
      if (!variableMap.has(variable.name)) {
        variableMap.set(variable.name, variable);
      }
    }
  }

  const rows = [...variableMap.values()]
    .sort((a, b) => a.name.localeCompare(b.name))
    .map((variable) => {
      const rawValue = state.globalVariables[variable.name];
      const displayValue = Array.isArray(rawValue) ? rawValue.join(', ') : rawValue ?? '';
      return `
      <label class="global-row">
        <code>{{${escapeHtml(variable.name)}}}</code>
        <input data-action="set-global-var" data-var-name="${escapeHtml(variable.name)}" value="${escapeHtml(displayValue)}" />
      </label>
    `;
    })
    .join('');
  els.globalVarEditor.innerHTML = rows || '<div class="empty-state">No variable definitions found.</div>';

  const presetNames = ['Select preset', ...Object.keys(state.presets)];
  els.presetSelect.innerHTML = presetNames
    .map((name) => `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`)
    .join('');
}

function batchExportCurrentView() {
  const prompts = filteredPrompts();
  const payload = prompts.map((prompt) => {
    const values = getPromptValueMap(prompt);
    return {
      id: prompt.id,
      title: prompt.title,
      category: prompt.category,
      roles: prompt.roles,
      domains: prompt.domains,
      version: prompt.version,
      assembledPrompt: assemblePrompt(prompt, values),
      values,
    };
  });
  downloadJson(`cib_prompt_batch_export_${Date.now()}.json`, payload);
}

function runCoverageCheck() {
  const report = validateCoverage(state.prompts);
  if (!report.meetsMinimums) {
    console.warn('Prompt coverage gaps detected:', report.gaps);
  } else {
    console.info('Prompt coverage check passed.', report.counts);
  }
}

function handleMainClick(event) {
  const button = event.target.closest('[data-action]');
  if (!button) return;

  const action = button.dataset.action;
  const promptId = button.dataset.promptId;

  if (action === 'open-prompt' && promptId) {
    openPrompt(promptId);
    return;
  }

  if (action === 'fork-prompt' && promptId) {
    const prompt = getPromptById(promptId);
    if (prompt) openForkModal(prompt);
    return;
  }

  if (action === 'toggle-favorite' && promptId) {
    if (state.favorites.has(promptId)) state.favorites.delete(promptId);
    else state.favorites.add(promptId);
    persistState();
    renderMain();
    return;
  }

  if (action === 'copy-prompt' && promptId) {
    const prompt = getPromptById(promptId);
    if (!prompt) return;
    const values = getPromptValueMap(prompt);
    const assembled = assemblePrompt(prompt, values);
    copyText(assembled);
    state.versionUsage[prompt.id] = prompt.version;
    incrementUsage(prompt.id);
    pushRecent(prompt.id);
    persistState();
    renderMain();
    return;
  }

  if (action === 'export-json' && promptId) {
    const prompt = getPromptById(promptId);
    if (!prompt) return;
    const values = getPromptValueMap(prompt);
    const assembled = assemblePrompt(prompt, values);
    downloadJson(`${prompt.id.replaceAll('.', '_')}_prompt.json`, {
      id: prompt.id,
      title: prompt.title,
      version: prompt.version,
      category: prompt.category,
      roles: prompt.roles,
      domains: prompt.domains,
      values,
      assembledPrompt: assembled,
    });
    state.versionUsage[prompt.id] = prompt.version;
    incrementUsage(prompt.id);
    persistState();
    renderMain();
    return;
  }

  if (action === 'export-pdf' && promptId) {
    const prompt = getPromptById(promptId);
    if (!prompt) return;
    const values = getPromptValueMap(prompt);
    const assembled = assemblePrompt(prompt, values);
    exportPromptPdfLike(prompt, assembled);
    state.versionUsage[prompt.id] = prompt.version;
    incrementUsage(prompt.id);
    persistState();
    renderMain();
    return;
  }

  if (action === 'set-rating' && promptId) {
    const ratingValue = Number(button.dataset.rating || 0);
    const existing = state.ratings[promptId] || { rating: 0, feedback: '' };
    state.ratings[promptId] = { ...existing, rating: ratingValue };
    persistState();
    renderMain();
    return;
  }

  if (action === 'set-global-from-var' && promptId) {
    const varName = button.dataset.varName;
    const prompt = getPromptById(promptId);
    if (!prompt || !varName) return;
    const values = getPromptValueMap(prompt);
    state.globalVariables[varName] = values[varName];
    persistState();
    return;
  }

  if (action === 'batch-export') {
    batchExportCurrentView();
    return;
  }

  if (action === 'add-context') {
    const title = document.getElementById('builderNewTitle')?.value?.trim();
    const content = document.getElementById('builderNewContent')?.value?.trim();
    if (!title || !content) return;
    state.builder.contextBlocks.push({ id: crypto.randomUUID(), title, content });
    persistState();
    renderBuilder();
    return;
  }

  if (action === 'remove-context') {
    const index = Number(button.dataset.index);
    if (!Number.isInteger(index)) return;
    state.builder.contextBlocks.splice(index, 1);
    persistState();
    renderBuilder();
    return;
  }

  if (action === 'toggle-output-format') {
    const checkbox = button;
    const value = checkbox.value;
    const set = new Set(state.builder.outputFormats);
    if (checkbox.checked) set.add(value);
    else set.delete(value);
    state.builder.outputFormats = [...set];
    persistState();
    return;
  }

  if (action === 'add-chain-step') {
    const selected = document.getElementById('builderChainPrompt')?.value;
    if (!selected) return;
    state.builder.chainSteps.push(selected);
    persistState();
    renderBuilder();
    return;
  }

  if (action === 'remove-chain-step') {
    const index = Number(button.dataset.index);
    if (!Number.isInteger(index)) return;
    state.builder.chainSteps.splice(index, 1);
    persistState();
    renderBuilder();
    return;
  }

  if (action === 'copy-builder') {
    copyText(builderGeneratedPrompt());
    return;
  }

  if (action === 'export-builder-json') {
    downloadJson(`builder_prompt_${Date.now()}.json`, {
      contextBlocks: state.builder.contextBlocks,
      taskSpec: state.builder.taskSpec,
      inputSpec: state.builder.inputSpec,
      outputFormats: state.builder.outputFormats,
      guardrails: state.builder.guardrails,
      chainSteps: state.builder.chainSteps,
      assembledPrompt: builderGeneratedPrompt(),
    });
    return;
  }

  if (action === 'save-builder-template') {
    const name = document.getElementById('builderTemplateName')?.value?.trim();
    if (!name) return;
    const existing = state.builder.templates || [];
    const template = {
      id: crypto.randomUUID(),
      name,
      version: '1.0.0',
      payload: {
        contextBlocks: structuredClone(state.builder.contextBlocks),
        taskSpec: state.builder.taskSpec,
        inputSpec: state.builder.inputSpec,
        outputFormats: structuredClone(state.builder.outputFormats),
        guardrails: state.builder.guardrails,
        chainSteps: structuredClone(state.builder.chainSteps),
      },
    };
    existing.push(template);
    state.builder.templates = existing;
    persistState();
    renderBuilder();
    return;
  }

  if (action === 'load-builder-template') {
    const templateId = button.dataset.templateId;
    const template = (state.builder.templates || []).find((item) => item.id === templateId);
    if (!template) return;
    state.builder = {
      ...state.builder,
      ...template.payload,
    };
    persistState();
    renderBuilder();
    return;
  }

  if (action === 'delete-builder-template') {
    const templateId = button.dataset.templateId;
    state.builder.templates = (state.builder.templates || []).filter((item) => item.id !== templateId);
    persistState();
    renderBuilder();
    return;
  }

  if (action === 'create-chain') {
    const name = document.getElementById('workflowName')?.value?.trim();
    if (!name) return;
    const chain = {
      id: crypto.randomUUID(),
      name,
      version: '1.0.0',
      steps: [],
      updatedAt: new Date().toISOString(),
      history: [{ version: '1.0.0', updatedAt: new Date().toISOString(), steps: [] }],
    };
    state.workflow.chains.push(chain);
    state.workflow.selectedChainId = chain.id;
    persistState();
    renderWorkflow();
    return;
  }

  if (action === 'select-chain') {
    state.workflow.selectedChainId = button.dataset.chainId;
    persistState();
    renderWorkflow();
    return;
  }

  if (action === 'add-workflow-step') {
    const selectedChain = state.workflow.chains.find((chain) => chain.id === state.workflow.selectedChainId) || state.workflow.chains[0];
    if (!selectedChain) return;
    const promptSelection = document.getElementById('workflowStepPrompt')?.value;
    if (!promptSelection) return;
    selectedChain.steps.push(promptSelection);
    selectedChain.updatedAt = new Date().toISOString();
    persistState();
    renderWorkflow();
    return;
  }

  if (action === 'remove-workflow-step') {
    const selectedChain = state.workflow.chains.find((chain) => chain.id === state.workflow.selectedChainId) || state.workflow.chains[0];
    if (!selectedChain) return;
    const index = Number(button.dataset.index);
    selectedChain.steps.splice(index, 1);
    selectedChain.updatedAt = new Date().toISOString();
    persistState();
    renderWorkflow();
    return;
  }

  if (action === 'save-workflow-version') {
    const selectedChain = state.workflow.chains.find((chain) => chain.id === state.workflow.selectedChainId) || state.workflow.chains[0];
    if (!selectedChain) return;
    const currentVersion = selectedChain.version || '1.0.0';
    const parts = currentVersion.split('.').map((item) => Number(item));
    const nextVersion = `${parts[0] || 1}.${parts[1] || 0}.${(parts[2] || 0) + 1}`;
    selectedChain.version = nextVersion;
    selectedChain.updatedAt = new Date().toISOString();
    selectedChain.history = selectedChain.history || [];
    selectedChain.history.push({
      version: nextVersion,
      updatedAt: selectedChain.updatedAt,
      steps: structuredClone(selectedChain.steps),
    });
    persistState();
    renderWorkflow();
    return;
  }

  if (action === 'export-workflow-json') {
    const selectedChain = state.workflow.chains.find((chain) => chain.id === state.workflow.selectedChainId) || state.workflow.chains[0];
    if (!selectedChain) return;
    downloadJson(`${slugify(selectedChain.name)}_chain.json`, selectedChain);
    return;
  }

  if (action === 'approve-review' || action === 'reject-review') {
    const reviewId = button.dataset.reviewId;
    const entry = state.reviewQueue.find((item) => item.id === reviewId);
    if (!entry) return;
    entry.status = action === 'approve-review' ? 'Approved' : 'Rejected';
    entry.decidedAt = new Date().toISOString();
    persistState();
    renderLibrary();
    return;
  }

  if (action === 'run-command-item') {
    const type = button.dataset.commandType;
    const value = button.dataset.commandValue;
    runCommand(type, value);
    return;
  }
}

function handleMainInput(event) {
  const target = event.target;
  if (!(target instanceof HTMLElement)) return;

  if (target.dataset.action === 'set-var') {
    const promptId = target.dataset.promptId;
    const varName = target.dataset.varName;
    const prompt = getPromptById(promptId);
    if (!prompt || !varName) return;

    const variable = prompt.variables.find((item) => item.name === varName);
    if (!variable) return;

    let value;
    if (variable.type === 'multiselect' && target instanceof HTMLSelectElement) {
      value = [...target.selectedOptions].map((option) => option.value);
    } else if (variable.type === 'slider' || variable.type === 'number') {
      value = Number(target.value);
    } else {
      value = target.value;
    }

    state.promptValues[promptId] = state.promptValues[promptId] || {};
    state.promptValues[promptId][varName] = value;

    const selectorValue =
      window.CSS && typeof window.CSS.escape === 'function'
        ? window.CSS.escape(`${promptId}|${varName}`)
        : `${promptId}|${varName}`.replaceAll('"', '\\"');
    const rangeValue = document.querySelector(`[data-range-value="${selectorValue}"]`);
    if (rangeValue) rangeValue.textContent = String(value);

    const selectedPrompt = getPromptById(state.selectedPromptId);
    if (selectedPrompt) {
      const assembled = assemblePrompt(selectedPrompt, getPromptValueMap(selectedPrompt));
      const preview = document.getElementById('assembledPreview');
      if (preview) preview.textContent = assembled;
    }

    persistState();
    return;
  }

  if (target.dataset.action === 'set-feedback') {
    const promptId = target.dataset.promptId;
    if (!promptId) return;
    const existing = state.ratings[promptId] || { rating: 0, feedback: '' };
    state.ratings[promptId] = { ...existing, feedback: target.value };
    persistState();
    return;
  }

  if (target.dataset.action === 'builder-field') {
    const field = target.dataset.field;
    if (!field) return;
    state.builder[field] = target.value;
    persistState();
    return;
  }
}

function setupDragAndDrop() {
  els.main.addEventListener('dragstart', (event) => {
    const target = event.target.closest('[data-builder-drag], [data-workflow-drag]');
    if (!target) return;
    const dragType = target.dataset.builderDrag || target.dataset.workflowDrag;
    const index = Number(target.dataset.index);
    event.dataTransfer.setData('text/plain', JSON.stringify({ dragType, index }));
    target.classList.add('dragging');
  });

  els.main.addEventListener('dragend', (event) => {
    const target = event.target.closest('.drag-item, .workflow-step');
    if (target) target.classList.remove('dragging');
  });

  els.main.addEventListener('dragover', (event) => {
    if (event.target.closest('#contextDragZone, #chainDragZone, #workflowStepZone')) {
      event.preventDefault();
    }
  });

  els.main.addEventListener('drop', (event) => {
    const dropZone = event.target.closest('#contextDragZone, #chainDragZone, #workflowStepZone');
    if (!dropZone) return;
    event.preventDefault();

    const payload = safeJsonParse(event.dataTransfer.getData('text/plain'), null);
    if (!payload) return;

    const dropTarget = event.target.closest('[data-index]');
    const dropIndex = dropTarget ? Number(dropTarget.dataset.index) : null;

    if (dropZone.id === 'contextDragZone' && payload.dragType === 'context') {
      const from = payload.index;
      const to = Number.isInteger(dropIndex) ? dropIndex : state.builder.contextBlocks.length - 1;
      if (from === to || from < 0 || to < 0) return;
      const moved = state.builder.contextBlocks.splice(from, 1)[0];
      state.builder.contextBlocks.splice(to, 0, moved);
      persistState();
      renderBuilder();
      return;
    }

    if (dropZone.id === 'chainDragZone' && payload.dragType === 'chain') {
      const from = payload.index;
      const to = Number.isInteger(dropIndex) ? dropIndex : state.builder.chainSteps.length - 1;
      if (from === to || from < 0 || to < 0) return;
      const moved = state.builder.chainSteps.splice(from, 1)[0];
      state.builder.chainSteps.splice(to, 0, moved);
      persistState();
      renderBuilder();
      return;
    }

    if (dropZone.id === 'workflowStepZone' && payload.dragType === 'step') {
      const selectedChain =
        state.workflow.chains.find((chain) => chain.id === state.workflow.selectedChainId) || state.workflow.chains[0];
      if (!selectedChain) return;
      const from = payload.index;
      const to = Number.isInteger(dropIndex) ? dropIndex : selectedChain.steps.length - 1;
      if (from === to || from < 0 || to < 0) return;
      const moved = selectedChain.steps.splice(from, 1)[0];
      selectedChain.steps.splice(to, 0, moved);
      persistState();
      renderWorkflow();
    }
  });
}

function setupTopLevelEvents() {
  els.nav.addEventListener('click', (event) => {
    const button = event.target.closest('.nav-item');
    if (!button) return;
    state.view = button.dataset.view;
    persistState();
    renderMain();
  });

  els.searchInput.addEventListener('input', (event) => {
    state.filters.query = event.target.value;
    if (state.view !== 'role' && state.view !== 'function') {
      state.view = 'function';
    }
    persistState();
    renderMain();
  });

  els.domainFilter.addEventListener('change', (event) => {
    state.filters.domain = event.target.value;
    if (state.view !== 'role' && state.view !== 'function') state.view = 'function';
    persistState();
    renderMain();
  });

  els.complexityFilter.addEventListener('change', (event) => {
    state.filters.complexity = event.target.value;
    if (state.view !== 'role' && state.view !== 'function') state.view = 'function';
    persistState();
    renderMain();
  });

  els.regulatoryFilter.addEventListener('change', (event) => {
    state.filters.regulatory = event.target.value;
    if (state.view !== 'role' && state.view !== 'function') state.view = 'function';
    persistState();
    renderMain();
  });

  els.outputFilter.addEventListener('change', (event) => {
    state.filters.outputType = event.target.value;
    if (state.view !== 'role' && state.view !== 'function') state.view = 'function';
    persistState();
    renderMain();
  });

  els.roleSelector.addEventListener('change', (event) => {
    state.selectedRole = event.target.value;
    persistState();
    renderMain();
  });

  els.themeToggle.addEventListener('click', () => {
    setTheme(state.theme === 'dark' ? 'light' : 'dark');
    persistState();
  });

  els.openGlobalVars.addEventListener('click', () => {
    renderGlobalVariablesEditor();
    openOverlay(els.globalVarsModal);
  });

  els.openCommandPalette.addEventListener('click', () => {
    openCommandPalette();
  });

  document.addEventListener('click', (event) => {
    const closer = event.target.closest('[data-close]');
    if (!closer) return;
    const targetId = closer.dataset.close;
    const target = document.getElementById(targetId);
    if (target) closeOverlay(target);
  });

  els.commandInput.addEventListener('input', (event) => {
    commandSelectionIndex = 0;
    renderCommandPalette(event.target.value);
  });

  els.commandResults.addEventListener('mousemove', (event) => {
    const item = event.target.closest('.command-item');
    if (!item) return;
    const items = [...els.commandResults.querySelectorAll('.command-item')];
    commandSelectionIndex = Math.max(0, items.indexOf(item));
    renderCommandPalette(els.commandInput.value);
  });

  els.forkForm.addEventListener('submit', (event) => {
    event.preventDefault();
    const sourcePrompt = getPromptById(forkSourcePromptId);
    const now = new Date().toISOString();
    const customPrompt = {
      id: `MY-${Date.now()}`,
      title: els.forkTitle.value.trim(),
      category: sourcePrompt?.category || 'Workflows & Chains',
      section: 'My Library',
      roles: els.forkRoles.value
        .split(',')
        .map((item) => item.trim())
        .filter(Boolean),
      domains: els.forkDomains.value
        .split(',')
        .map((item) => item.trim())
        .filter(Boolean),
      riskType: sourcePrompt?.riskType || 'Custom',
      complexity: els.forkComplexity.value,
      regulatory: sourcePrompt?.regulatory || [],
      outputTypes: sourcePrompt?.outputTypes || ['Structured Report'],
      version: '1.0.0',
      complianceTag: els.forkCompliance.value,
      usageNotes: els.forkUsageNotes.value.trim() || defaultUsageNotes,
      prompt: els.forkPrompt.value,
      variables: sourcePrompt?.variables || [],
      related: [],
      versions: [
        {
          version: '1.0.0',
          changedAt: now,
          notes: sourcePrompt ? `Forked from ${sourcePrompt.id}` : 'Custom prompt',
          prompt: els.forkPrompt.value,
        },
      ],
    };

    state.customPrompts.push(customPrompt);
    mergeAllPrompts();
    state.selectedPromptId = customPrompt.id;
    state.view = 'library';

    if (submitReviewFlag) {
      state.reviewQueue.push({
        id: crypto.randomUUID(),
        promptId: customPrompt.id,
        title: customPrompt.title,
        status: 'Pending',
        submittedAt: now,
      });
    }

    persistState();
    closeOverlay(els.forkModal);
    renderMain();
  });

  els.submitForReview.addEventListener('click', () => {
    submitReviewFlag = true;
    els.forkForm.requestSubmit();
  });

  els.globalVarEditor.addEventListener('input', (event) => {
    const target = event.target;
    if (!(target instanceof HTMLElement)) return;
    if (target.dataset.action !== 'set-global-var') return;
    const varName = target.dataset.varName;
    if (!varName) return;
    state.globalVariables[varName] = target.value;
    persistState();
  });

  els.savePresetBtn.addEventListener('click', () => {
    const name = els.presetNameInput.value.trim();
    if (!name) return;
    state.presets[name] = structuredClone(state.globalVariables);
    els.presetNameInput.value = '';
    persistState();
    renderGlobalVariablesEditor();
  });

  els.loadPresetBtn.addEventListener('click', () => {
    const name = els.presetSelect.value;
    if (!name || name === 'Select preset') return;
    const preset = state.presets[name];
    if (!preset) return;
    state.globalVariables = structuredClone(preset);
    persistState();
    renderGlobalVariablesEditor();
    renderMain();
  });

  els.main.addEventListener('click', handleMainClick);
  els.main.addEventListener('input', handleMainInput);

  setupDragAndDrop();

  document.addEventListener('keydown', (event) => {
    const target = event.target;
    const isTypingTarget =
      target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement;

    if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'k') {
      event.preventDefault();
      openCommandPalette();
      return;
    }

    if (event.key === 'Escape') {
      closeOverlay(els.commandPalette);
      closeOverlay(els.forkModal);
      closeOverlay(els.globalVarsModal);
      return;
    }

    if (!els.commandPalette.classList.contains('hidden')) {
      const items = [...els.commandResults.querySelectorAll('.command-item')];
      if (!items.length) return;
      if (event.key === 'ArrowDown') {
        event.preventDefault();
        commandSelectionIndex = Math.min(commandSelectionIndex + 1, items.length - 1);
        renderCommandPalette(els.commandInput.value);
      } else if (event.key === 'ArrowUp') {
        event.preventDefault();
        commandSelectionIndex = Math.max(commandSelectionIndex - 1, 0);
        renderCommandPalette(els.commandInput.value);
      } else if (event.key === 'Enter') {
        event.preventDefault();
        const active = items[commandSelectionIndex];
        if (active) {
          runCommand(active.dataset.commandType, active.dataset.commandValue);
        }
      }
      return;
    }

    if (isTypingTarget) return;

    if ((state.view === 'role' || state.view === 'function') && (event.key === 'j' || event.key === 'k')) {
      const prompts = filteredPrompts();
      if (!prompts.length) return;
      const currentIndex = Math.max(
        0,
        prompts.findIndex((prompt) => prompt.id === state.selectedPromptId),
      );
      const nextIndex = event.key === 'j' ? Math.min(currentIndex + 1, prompts.length - 1) : Math.max(currentIndex - 1, 0);
      state.selectedPromptId = prompts[nextIndex].id;
      pushRecent(prompts[nextIndex].id);
      persistState();
      renderMain();
    }
  });
}

function init() {
  loadState();
  setTheme(state.theme);
  setupFilters();
  setupTopLevelEvents();
  runCoverageCheck();
  renderMain();
}

init();

</script>
  </body>
</html>
